/**
 * Generated by orval v7.5.0 üç∫
 * Do not edit manually.
 * MangaDex API
 * MangaDex is an ad-free manga reader offering high-quality images!

This document details our API as it is right now. It is in no way a promise to never change it, although we will endeavour to publicly notify any major change.

# Acceptable use policy

Usage of our services implies acceptance of the following:
- You **MUST** credit us
- You **MUST** credit scanlation groups if you offer the ability to read chapters
- You **CANNOT** run ads or paid services on your website and/or apps

These may change at any time for any and no reason and it is up to you check for updates from time to time.

# Security issues

If you believe you found a security issue in our API, please check our [security.txt](/security.txt) to get in touch privately.

 * OpenAPI spec version: 5.10.2
 */
import {
  z as zod
} from 'zod'


/**
 * Search a list of Manga.
 * @summary Manga list
 */
export const getSearchMangaQueryLimitMin = 0;

export const getSearchMangaQueryLimitMax = 100;

export const getSearchMangaQueryLimitRegExp = new RegExp('^\\d+$');
export const getSearchMangaQueryOffsetMin = 0;

export const getSearchMangaQueryOffsetRegExp = new RegExp('^\\d+$');
export const getSearchMangaQueryYearRegExpOne = new RegExp('^\\\\d{4}$');
export const getSearchMangaQueryOriginalLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getSearchMangaQueryExcludedOriginalLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getSearchMangaQueryAvailableTranslatedLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getSearchMangaQueryCreatedAtSinceRegExp = new RegExp('^\\d{4}-[0-1]\\d-([0-2]\\d|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$');
export const getSearchMangaQueryUpdatedAtSinceRegExp = new RegExp('^\\d{4}-[0-1]\\d-([0-2]\\d|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$');


export const getSearchMangaQueryParams = zod.object({
  "limit": zod.number().min(getSearchMangaQueryLimitMin).max(getSearchMangaQueryLimitMax).regex(getSearchMangaQueryLimitRegExp).optional(),
  "offset": zod.number().min(getSearchMangaQueryOffsetMin).regex(getSearchMangaQueryOffsetRegExp).optional(),
  "title": zod.string().optional(),
  "authorOrArtist": zod.string().uuid().optional(),
  "authors[]": zod.array(zod.string().uuid()).optional(),
  "artists[]": zod.array(zod.string().uuid()).optional(),
  "year": zod.number().regex(getSearchMangaQueryYearRegExpOne).or(zod.enum(['none'])).optional(),
  "includedTags[]": zod.array(zod.string().uuid()).optional(),
  "includedTagsMode": zod.enum(['AND', 'OR']).optional(),
  "excludedTags[]": zod.array(zod.string().uuid()).optional(),
  "excludedTagsMode": zod.enum(['AND', 'OR']).optional(),
  "status[]": zod.array(zod.enum(['ongoing', 'completed', 'hiatus', 'cancelled'])).optional(),
  "originalLanguage[]": zod.array(zod.string().regex(getSearchMangaQueryOriginalLanguageItemRegExp)).optional(),
  "excludedOriginalLanguage[]": zod.array(zod.string().regex(getSearchMangaQueryExcludedOriginalLanguageItemRegExp)).optional(),
  "availableTranslatedLanguage[]": zod.array(zod.string().regex(getSearchMangaQueryAvailableTranslatedLanguageItemRegExp)).optional(),
  "publicationDemographic[]": zod.array(zod.enum(['shounen', 'shoujo', 'josei', 'seinen', 'none'])).optional(),
  "ids[]": zod.array(zod.string().uuid()).optional(),
  "contentRating[]": zod.array(zod.enum(['safe', 'suggestive', 'erotica', 'pornographic'])).optional(),
  "createdAtSince": zod.string().regex(getSearchMangaQueryCreatedAtSinceRegExp).optional(),
  "updatedAtSince": zod.string().regex(getSearchMangaQueryUpdatedAtSinceRegExp).optional(),
  "order": zod.object({
  "title": zod.enum(['asc', 'desc']).optional(),
  "year": zod.enum(['asc', 'desc']).optional(),
  "createdAt": zod.enum(['asc', 'desc']).optional(),
  "updatedAt": zod.enum(['asc', 'desc']).optional(),
  "latestUploadedChapter": zod.enum(['asc', 'desc']).optional(),
  "followedCount": zod.enum(['asc', 'desc']).optional(),
  "relevance": zod.enum(['asc', 'desc']).optional(),
  "rating": zod.enum(['asc', 'desc']).optional()
}).optional(),
  "includes[]": zod.array(zod.enum(['manga', 'cover_art', 'author', 'artist', 'tag', 'creator'])).optional(),
  "hasAvailableChapters": zod.enum(['0', '1', 'true', 'false']).optional(),
  "group": zod.string().uuid().optional()
})

export const getSearchMangaResponseDataItemAttributesTitleRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getSearchMangaResponseDataItemAttributesAltTitlesItemRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getSearchMangaResponseDataItemAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getSearchMangaResponseDataItemAttributesAvailableTranslatedLanguagesItemRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const getSearchMangaResponseDataItemAttributesTagsItemAttributesNameRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getSearchMangaResponseDataItemAttributesTagsItemAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');


export const getSearchMangaResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['manga']).optional(),
  "attributes": zod.object({
  "title": zod.record(zod.string(), zod.string().regex(getSearchMangaResponseDataItemAttributesTitleRegExpOne)).optional(),
  "altTitles": zod.array(zod.record(zod.string(), zod.string().regex(getSearchMangaResponseDataItemAttributesAltTitlesItemRegExpOne))).optional(),
  "description": zod.record(zod.string(), zod.string().regex(getSearchMangaResponseDataItemAttributesDescriptionRegExpOne)).optional(),
  "isLocked": zod.boolean().optional(),
  "links": zod.record(zod.string(), zod.string()).optional(),
  "originalLanguage": zod.string().optional(),
  "lastVolume": zod.string().nullish(),
  "lastChapter": zod.string().nullish(),
  "publicationDemographic": zod.enum(['shounen', 'shoujo', 'josei', 'seinen']).nullish(),
  "status": zod.enum(['completed', 'ongoing', 'cancelled', 'hiatus']).optional(),
  "year": zod.number().nullish(),
  "contentRating": zod.enum(['safe', 'suggestive', 'erotica', 'pornographic']).optional(),
  "chapterNumbersResetOnNewVolume": zod.boolean().optional(),
  "availableTranslatedLanguages": zod.array(zod.string().regex(getSearchMangaResponseDataItemAttributesAvailableTranslatedLanguagesItemRegExp)).optional(),
  "latestUploadedChapter": zod.string().uuid().optional(),
  "tags": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['tag']).optional(),
  "attributes": zod.object({
  "name": zod.record(zod.string(), zod.string().regex(getSearchMangaResponseDataItemAttributesTagsItemAttributesNameRegExpOne)).optional(),
  "description": zod.record(zod.string(), zod.string().regex(getSearchMangaResponseDataItemAttributesTagsItemAttributesDescriptionRegExpOne)).optional(),
  "group": zod.enum(['content', 'format', 'genre', 'theme']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "state": zod.enum(['draft', 'submitted', 'published', 'rejected']).optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * Create a new Manga.
 * @summary Create Manga
 */
export const postMangaHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const postMangaBodyTitleRegExpOne = new RegExp('^[a-z]{2,8}$');
export const postMangaBodyAltTitlesItemRegExpOne = new RegExp('^[a-z]{2,8}$');
export const postMangaBodyDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');
export const postMangaBodyOriginalLanguageRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const postMangaBodyYearMax = 9999;


export const postMangaBody = zod.object({
  "title": zod.record(zod.string(), zod.string().regex(postMangaBodyTitleRegExpOne)).optional(),
  "altTitles": zod.array(zod.record(zod.string(), zod.string().regex(postMangaBodyAltTitlesItemRegExpOne))).optional(),
  "description": zod.record(zod.string(), zod.string().regex(postMangaBodyDescriptionRegExpOne)).optional(),
  "authors": zod.array(zod.string().uuid()).optional(),
  "artists": zod.array(zod.string().uuid()).optional(),
  "links": zod.record(zod.string(), zod.string()).optional(),
  "originalLanguage": zod.string().regex(postMangaBodyOriginalLanguageRegExp).optional(),
  "lastVolume": zod.string().nullish(),
  "lastChapter": zod.string().nullish(),
  "publicationDemographic": zod.enum(['shounen', 'shoujo', 'josei', 'seinen']).nullish(),
  "status": zod.enum(['completed', 'ongoing', 'cancelled', 'hiatus']).optional(),
  "year": zod.number().min(1).max(postMangaBodyYearMax).nullish(),
  "contentRating": zod.enum(['safe', 'suggestive', 'erotica', 'pornographic']).optional(),
  "chapterNumbersResetOnNewVolume": zod.boolean().optional(),
  "tags": zod.array(zod.string().uuid()).optional(),
  "primaryCover": zod.string().uuid().nullish(),
  "version": zod.number().min(1).optional()
}).and(zod.any())

export const postMangaResponseDataAttributesTitleRegExpOne = new RegExp('^[a-z]{2,8}$');
export const postMangaResponseDataAttributesAltTitlesItemRegExpOne = new RegExp('^[a-z]{2,8}$');
export const postMangaResponseDataAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');
export const postMangaResponseDataAttributesAvailableTranslatedLanguagesItemRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const postMangaResponseDataAttributesTagsItemAttributesNameRegExpOne = new RegExp('^[a-z]{2,8}$');
export const postMangaResponseDataAttributesTagsItemAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');


export const postMangaResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['manga']).optional(),
  "attributes": zod.object({
  "title": zod.record(zod.string(), zod.string().regex(postMangaResponseDataAttributesTitleRegExpOne)).optional(),
  "altTitles": zod.array(zod.record(zod.string(), zod.string().regex(postMangaResponseDataAttributesAltTitlesItemRegExpOne))).optional(),
  "description": zod.record(zod.string(), zod.string().regex(postMangaResponseDataAttributesDescriptionRegExpOne)).optional(),
  "isLocked": zod.boolean().optional(),
  "links": zod.record(zod.string(), zod.string()).optional(),
  "originalLanguage": zod.string().optional(),
  "lastVolume": zod.string().nullish(),
  "lastChapter": zod.string().nullish(),
  "publicationDemographic": zod.enum(['shounen', 'shoujo', 'josei', 'seinen']).nullish(),
  "status": zod.enum(['completed', 'ongoing', 'cancelled', 'hiatus']).optional(),
  "year": zod.number().nullish(),
  "contentRating": zod.enum(['safe', 'suggestive', 'erotica', 'pornographic']).optional(),
  "chapterNumbersResetOnNewVolume": zod.boolean().optional(),
  "availableTranslatedLanguages": zod.array(zod.string().regex(postMangaResponseDataAttributesAvailableTranslatedLanguagesItemRegExp)).optional(),
  "latestUploadedChapter": zod.string().uuid().optional(),
  "tags": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['tag']).optional(),
  "attributes": zod.object({
  "name": zod.record(zod.string(), zod.string().regex(postMangaResponseDataAttributesTagsItemAttributesNameRegExpOne)).optional(),
  "description": zod.record(zod.string(), zod.string().regex(postMangaResponseDataAttributesTagsItemAttributesDescriptionRegExpOne)).optional(),
  "group": zod.enum(['content', 'format', 'genre', 'theme']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "state": zod.enum(['draft', 'submitted', 'published', 'rejected']).optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Get Manga volumes & chapters
 */
export const getMangaAggregateQueryTranslatedLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getMangaAggregateQueryGroupsItemMin = 36;

export const getMangaAggregateQueryGroupsItemMax = 36;


export const getMangaAggregateQueryParams = zod.object({
  "translatedLanguage[]": zod.array(zod.string().regex(getMangaAggregateQueryTranslatedLanguageItemRegExp)).optional(),
  "groups[]": zod.array(zod.string().uuid().min(getMangaAggregateQueryGroupsItemMin).max(getMangaAggregateQueryGroupsItemMax)).optional()
})

export const getMangaAggregateResponse = zod.object({
  "result": zod.string().optional(),
  "volumes": zod.record(zod.string(), zod.object({
  "volume": zod.string().optional(),
  "count": zod.number().optional(),
  "chapters": zod.record(zod.string(), zod.object({
  "chapter": zod.string().optional(),
  "id": zod.string().uuid().optional(),
  "others": zod.array(zod.string().uuid()).optional(),
  "count": zod.number().optional()
})).optional()
})).optional()
})


/**
 * Get Manga.
 * @summary Get Manga
 */
export const getMangaIdQueryParams = zod.object({
  "includes[]": zod.array(zod.enum(['manga', 'cover_art', 'author', 'artist', 'tag', 'creator'])).optional()
})

export const getMangaIdResponseDataAttributesTitleRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaIdResponseDataAttributesAltTitlesItemRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaIdResponseDataAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaIdResponseDataAttributesAvailableTranslatedLanguagesItemRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const getMangaIdResponseDataAttributesTagsItemAttributesNameRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaIdResponseDataAttributesTagsItemAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');


export const getMangaIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['manga']).optional(),
  "attributes": zod.object({
  "title": zod.record(zod.string(), zod.string().regex(getMangaIdResponseDataAttributesTitleRegExpOne)).optional(),
  "altTitles": zod.array(zod.record(zod.string(), zod.string().regex(getMangaIdResponseDataAttributesAltTitlesItemRegExpOne))).optional(),
  "description": zod.record(zod.string(), zod.string().regex(getMangaIdResponseDataAttributesDescriptionRegExpOne)).optional(),
  "isLocked": zod.boolean().optional(),
  "links": zod.record(zod.string(), zod.string()).optional(),
  "originalLanguage": zod.string().optional(),
  "lastVolume": zod.string().nullish(),
  "lastChapter": zod.string().nullish(),
  "publicationDemographic": zod.enum(['shounen', 'shoujo', 'josei', 'seinen']).nullish(),
  "status": zod.enum(['completed', 'ongoing', 'cancelled', 'hiatus']).optional(),
  "year": zod.number().nullish(),
  "contentRating": zod.enum(['safe', 'suggestive', 'erotica', 'pornographic']).optional(),
  "chapterNumbersResetOnNewVolume": zod.boolean().optional(),
  "availableTranslatedLanguages": zod.array(zod.string().regex(getMangaIdResponseDataAttributesAvailableTranslatedLanguagesItemRegExp)).optional(),
  "latestUploadedChapter": zod.string().uuid().optional(),
  "tags": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['tag']).optional(),
  "attributes": zod.object({
  "name": zod.record(zod.string(), zod.string().regex(getMangaIdResponseDataAttributesTagsItemAttributesNameRegExpOne)).optional(),
  "description": zod.record(zod.string(), zod.string().regex(getMangaIdResponseDataAttributesTagsItemAttributesDescriptionRegExpOne)).optional(),
  "group": zod.enum(['content', 'format', 'genre', 'theme']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "state": zod.enum(['draft', 'submitted', 'published', 'rejected']).optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Update Manga
 */
export const putMangaIdHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const putMangaIdBodyTitleRegExpOne = new RegExp('^[a-z]{2,8}$');
export const putMangaIdBodyAltTitlesItemRegExpOne = new RegExp('^[a-z]{2,8}$');
export const putMangaIdBodyDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');
export const putMangaIdBodyOriginalLanguageRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const putMangaIdBodyYearMax = 9999;
export const putMangaIdBodyArtistsItemMinOne = 36;

export const putMangaIdBodyArtistsItemMaxOne = 36;
export const putMangaIdBodyAuthorsItemMinOne = 36;

export const putMangaIdBodyAuthorsItemMaxOne = 36;


export const putMangaIdBody = zod.object({
  "title": zod.record(zod.string(), zod.string().regex(putMangaIdBodyTitleRegExpOne)).optional(),
  "altTitles": zod.array(zod.record(zod.string(), zod.string().regex(putMangaIdBodyAltTitlesItemRegExpOne))).optional(),
  "description": zod.record(zod.string(), zod.string().regex(putMangaIdBodyDescriptionRegExpOne)).optional(),
  "authors": zod.array(zod.string().uuid()).optional(),
  "artists": zod.array(zod.string().uuid()).optional(),
  "links": zod.record(zod.string(), zod.string()).optional(),
  "originalLanguage": zod.string().regex(putMangaIdBodyOriginalLanguageRegExp).optional(),
  "lastVolume": zod.string().nullish(),
  "lastChapter": zod.string().nullish(),
  "publicationDemographic": zod.enum(['shounen', 'shoujo', 'josei', 'seinen']).nullish(),
  "status": zod.enum(['completed', 'ongoing', 'cancelled', 'hiatus']).optional(),
  "year": zod.number().min(1).max(putMangaIdBodyYearMax).nullish(),
  "contentRating": zod.enum(['safe', 'suggestive', 'erotica', 'pornographic']).optional(),
  "chapterNumbersResetOnNewVolume": zod.boolean().optional(),
  "tags": zod.array(zod.string().uuid()).optional(),
  "primaryCover": zod.string().uuid().nullish(),
  "version": zod.number().min(1).optional()
}).and(zod.any()).and(zod.object({
  "artists": zod.array(zod.string().uuid().min(putMangaIdBodyArtistsItemMinOne).max(putMangaIdBodyArtistsItemMaxOne)).optional(),
  "authors": zod.array(zod.string().uuid().min(putMangaIdBodyAuthorsItemMinOne).max(putMangaIdBodyAuthorsItemMaxOne)).optional()
}))

export const putMangaIdResponseDataAttributesTitleRegExpOne = new RegExp('^[a-z]{2,8}$');
export const putMangaIdResponseDataAttributesAltTitlesItemRegExpOne = new RegExp('^[a-z]{2,8}$');
export const putMangaIdResponseDataAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');
export const putMangaIdResponseDataAttributesAvailableTranslatedLanguagesItemRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const putMangaIdResponseDataAttributesTagsItemAttributesNameRegExpOne = new RegExp('^[a-z]{2,8}$');
export const putMangaIdResponseDataAttributesTagsItemAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');


export const putMangaIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['manga']).optional(),
  "attributes": zod.object({
  "title": zod.record(zod.string(), zod.string().regex(putMangaIdResponseDataAttributesTitleRegExpOne)).optional(),
  "altTitles": zod.array(zod.record(zod.string(), zod.string().regex(putMangaIdResponseDataAttributesAltTitlesItemRegExpOne))).optional(),
  "description": zod.record(zod.string(), zod.string().regex(putMangaIdResponseDataAttributesDescriptionRegExpOne)).optional(),
  "isLocked": zod.boolean().optional(),
  "links": zod.record(zod.string(), zod.string()).optional(),
  "originalLanguage": zod.string().optional(),
  "lastVolume": zod.string().nullish(),
  "lastChapter": zod.string().nullish(),
  "publicationDemographic": zod.enum(['shounen', 'shoujo', 'josei', 'seinen']).nullish(),
  "status": zod.enum(['completed', 'ongoing', 'cancelled', 'hiatus']).optional(),
  "year": zod.number().nullish(),
  "contentRating": zod.enum(['safe', 'suggestive', 'erotica', 'pornographic']).optional(),
  "chapterNumbersResetOnNewVolume": zod.boolean().optional(),
  "availableTranslatedLanguages": zod.array(zod.string().regex(putMangaIdResponseDataAttributesAvailableTranslatedLanguagesItemRegExp)).optional(),
  "latestUploadedChapter": zod.string().uuid().optional(),
  "tags": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['tag']).optional(),
  "attributes": zod.object({
  "name": zod.record(zod.string(), zod.string().regex(putMangaIdResponseDataAttributesTagsItemAttributesNameRegExpOne)).optional(),
  "description": zod.record(zod.string(), zod.string().regex(putMangaIdResponseDataAttributesTagsItemAttributesDescriptionRegExpOne)).optional(),
  "group": zod.enum(['content', 'format', 'genre', 'theme']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "state": zod.enum(['draft', 'submitted', 'published', 'rejected']).optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Delete Manga
 */
export const deleteMangaIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @deprecated
 * @summary Login
 */
export const postAuthLoginHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const postAuthLoginBodyUsernameMax = 64;
export const postAuthLoginBodyPasswordMin = 8;

export const postAuthLoginBodyPasswordMax = 1024;


export const postAuthLoginBody = zod.object({
  "username": zod.string().min(1).max(postAuthLoginBodyUsernameMax).optional(),
  "email": zod.string().optional(),
  "password": zod.string().min(postAuthLoginBodyPasswordMin).max(postAuthLoginBodyPasswordMax)
})

export const postAuthLoginResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional(),
  "token": zod.object({
  "session": zod.string().optional(),
  "refresh": zod.string().optional()
}).optional()
})


/**
 * The returned list of permissions is computed depending on the generic role permissions that the token user has, their personal overrides, and the OpenID scopes of the token (we do not offer granular token permissions yet)

 * @summary Check the set of permissions associated with the current token
 */
export const getAuthCheckResponse = zod.object({
  "result": zod.string().optional(),
  "isAuthenticated": zod.boolean().optional(),
  "roles": zod.array(zod.string()).optional(),
  "permissions": zod.array(zod.string()).optional()
})


/**
 * @deprecated
 * @summary Logout
 */
export const postAuthLogoutResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @deprecated
 * @summary Refresh token
 */
export const postAuthRefreshHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const postAuthRefreshBody = zod.object({
  "token": zod.string().min(1)
})

export const postAuthRefreshResponse = zod.object({
  "result": zod.enum(['ok', 'error']),
  "token": zod.object({
  "session": zod.string().optional(),
  "refresh": zod.string().optional()
}).optional(),
  "message": zod.string().optional()
})


/**
 * @summary List own Api Clients
 */
export const getListApiclientsQueryLimitMin = 0;

export const getListApiclientsQueryLimitMax = 100;
export const getListApiclientsQueryOffsetMin = 0;


export const getListApiclientsQueryParams = zod.object({
  "limit": zod.number().min(getListApiclientsQueryLimitMin).max(getListApiclientsQueryLimitMax).optional(),
  "offset": zod.number().min(getListApiclientsQueryOffsetMin).optional(),
  "state": zod.enum(['requested', 'approved', 'rejected', 'autoapproved']).optional(),
  "name": zod.string().optional(),
  "includes[]": zod.array(zod.enum(['creator'])).optional(),
  "order": zod.object({
  "name": zod.enum(['asc', 'desc']).optional(),
  "createdAt": zod.enum(['asc', 'desc']).optional(),
  "updatedAt": zod.enum(['asc', 'desc']).optional()
}).optional()
})

export const getListApiclientsResponseDataItemAttributesDescriptionMax = 256;


export const getListApiclientsResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['api_client']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "description": zod.string().max(getListApiclientsResponseDataItemAttributesDescriptionMax).nullish(),
  "profile": zod.string().optional(),
  "externalClientId": zod.string().nullish(),
  "isActive": zod.boolean().optional(),
  "state": zod.enum(['requested', 'approved', 'rejected', 'autoapproved']).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary Create ApiClient
 */
export const postCreateApiclientHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const postCreateApiclientBodyNameMin = 5;

export const postCreateApiclientBodyNameMax = 32;
export const postCreateApiclientBodyDescriptionMax = 256;


export const postCreateApiclientBody = zod.object({
  "name": zod.string().min(postCreateApiclientBodyNameMin).max(postCreateApiclientBodyNameMax),
  "description": zod.string().max(postCreateApiclientBodyDescriptionMax).nullish(),
  "profile": zod.enum(['personal']),
  "version": zod.number().min(1).optional()
})

export const postCreateApiclientResponseDataAttributesDescriptionMax = 256;


export const postCreateApiclientResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['api_client']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "description": zod.string().max(postCreateApiclientResponseDataAttributesDescriptionMax).nullish(),
  "profile": zod.string().optional(),
  "externalClientId": zod.string().nullish(),
  "isActive": zod.boolean().optional(),
  "state": zod.enum(['requested', 'approved', 'rejected', 'autoapproved']).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Get Api Client by ID
 */
export const getApiclientQueryParams = zod.object({
  "includes[]": zod.array(zod.enum(['creator'])).optional()
})

export const getApiclientResponseDataAttributesDescriptionMax = 256;


export const getApiclientResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['api_client']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "description": zod.string().max(getApiclientResponseDataAttributesDescriptionMax).nullish(),
  "profile": zod.string().optional(),
  "externalClientId": zod.string().nullish(),
  "isActive": zod.boolean().optional(),
  "state": zod.enum(['requested', 'approved', 'rejected', 'autoapproved']).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Edit ApiClient
 */
export const postEditApiclientHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const postEditApiclientBody = zod.object({
  "description": zod.string().nullish(),
  "version": zod.number().min(1)
})

export const postEditApiclientResponseDataAttributesDescriptionMax = 256;


export const postEditApiclientResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['api_client']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "description": zod.string().max(postEditApiclientResponseDataAttributesDescriptionMax).nullish(),
  "profile": zod.string().optional(),
  "externalClientId": zod.string().nullish(),
  "isActive": zod.boolean().optional(),
  "state": zod.enum(['requested', 'approved', 'rejected', 'autoapproved']).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Delete Api Client
 */
export const deleteApiclientQueryVersionRegExp = new RegExp('^\\d+$');


export const deleteApiclientQueryParams = zod.object({
  "version": zod.string().regex(deleteApiclientQueryVersionRegExp).optional()
})

export const deleteApiclientResponse = zod.object({
  "result": zod.string().optional()
})


/**
 * @summary Get Secret for Client by ID
 */
export const getApiclientSecretResponse = zod.object({
  "result": zod.enum(['ok']).optional(),
  "data": zod.string().optional()
})


/**
 * @summary Regenerate Client Secret
 */
export const postRegenerateApiclientSecretHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const postRegenerateApiclientSecretBody = zod.object({

})

export const postRegenerateApiclientSecretResponse = zod.object({
  "result": zod.enum(['ok']).optional(),
  "data": zod.string().optional()
})


/**
 * @summary Scanlation Group list
 */
export const getSearchGroupQueryLimitMin = 0;

export const getSearchGroupQueryLimitMax = 100;
export const getSearchGroupQueryOffsetMin = 0;


export const getSearchGroupQueryParams = zod.object({
  "limit": zod.number().min(getSearchGroupQueryLimitMin).max(getSearchGroupQueryLimitMax).optional(),
  "offset": zod.number().min(getSearchGroupQueryOffsetMin).optional(),
  "ids[]": zod.array(zod.string().uuid()).optional(),
  "name": zod.string().optional(),
  "focusedLanguage": zod.string().optional(),
  "includes[]": zod.array(zod.enum(['leader', 'member'])).optional(),
  "order": zod.object({
  "name": zod.enum(['asc', 'desc']).optional(),
  "createdAt": zod.enum(['asc', 'desc']).optional(),
  "updatedAt": zod.enum(['asc', 'desc']).optional(),
  "followedCount": zod.enum(['asc', 'desc']).optional(),
  "relevance": zod.enum(['asc', 'desc']).optional()
}).optional()
})

export const getSearchGroupResponseDataItemAttributesAltNamesItemRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getSearchGroupResponseDataItemAttributesTwitterRegExp = new RegExp('^https?:/');
export const getSearchGroupResponseDataItemAttributesMangaUpdatesMax = 128;

export const getSearchGroupResponseDataItemAttributesMangaUpdatesRegExp = new RegExp('^https:\\/\\/www\\.mangaupdates\\.com\\/(group|publisher)(s\\.html\\?id=\\d+|\\/[\\w-]+\\/?([\\w-]+)?(\\/)?)$');
export const getSearchGroupResponseDataItemAttributesFocusedLanguageItemRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const getSearchGroupResponseDataItemAttributesPublishDelayRegExp = new RegExp('^(P([1-9]|[1-9][0-9])D)?(P?([1-9])W)?(P?T(([1-9]|1[0-9]|2[0-4])H)?(([1-9]|[1-5][0-9]|60)M)?(([1-9]|[1-5][0-9]|60)S)?)?$');


export const getSearchGroupResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['scanlation_group']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "altNames": zod.array(zod.record(zod.string(), zod.string().regex(getSearchGroupResponseDataItemAttributesAltNamesItemRegExpOne))).optional(),
  "website": zod.string().nullish(),
  "ircServer": zod.string().nullish(),
  "ircChannel": zod.string().nullish(),
  "discord": zod.string().nullish(),
  "contactEmail": zod.string().nullish(),
  "description": zod.string().nullish(),
  "twitter": zod.string().url().regex(getSearchGroupResponseDataItemAttributesTwitterRegExp).nullish(),
  "mangaUpdates": zod.string().url().max(getSearchGroupResponseDataItemAttributesMangaUpdatesMax).regex(getSearchGroupResponseDataItemAttributesMangaUpdatesRegExp).nullish(),
  "focusedLanguage": zod.array(zod.string().regex(getSearchGroupResponseDataItemAttributesFocusedLanguageItemRegExp)).nullish(),
  "locked": zod.boolean().optional(),
  "official": zod.boolean().optional(),
  "verified": zod.boolean().optional(),
  "inactive": zod.boolean().optional(),
  "exLicensed": zod.boolean().optional(),
  "publishDelay": zod.string().regex(getSearchGroupResponseDataItemAttributesPublishDelayRegExp).optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary Create Scanlation Group
 */
export const postGroupHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const postGroupBodyTwitterRegExp = new RegExp('^https?://twitter\\.com');
export const postGroupBodyMangaUpdatesMax = 128;

export const postGroupBodyMangaUpdatesRegExp = new RegExp('^https:\\/\\/www\\.mangaupdates\\.com\\/(group|publisher)(s\\.html\\?id=\\d+|\\/[\\w-]+\\/?([\\w-]+)?(\\/)?)$');
export const postGroupBodyPublishDelayRegExp = new RegExp('^P(([1-9]|[1-9][0-9])D)?(([1-9])W)?(T(([1-9]|1[0-9]|2[0-4])H)?(([1-9]|[1-5][0-9]|60)M)?(([1-9]|[1-5][0-9]|60)S)?)?$');


export const postGroupBody = zod.object({
  "name": zod.string(),
  "website": zod.string().nullish(),
  "ircServer": zod.string().nullish(),
  "ircChannel": zod.string().nullish(),
  "discord": zod.string().nullish(),
  "contactEmail": zod.string().nullish(),
  "description": zod.string().nullish(),
  "twitter": zod.string().url().regex(postGroupBodyTwitterRegExp).nullish(),
  "mangaUpdates": zod.string().max(postGroupBodyMangaUpdatesMax).regex(postGroupBodyMangaUpdatesRegExp).nullish(),
  "inactive": zod.boolean().optional(),
  "publishDelay": zod.string().regex(postGroupBodyPublishDelayRegExp).nullish()
})

export const postGroupResponseDataAttributesAltNamesItemRegExpOne = new RegExp('^[a-z]{2,8}$');
export const postGroupResponseDataAttributesTwitterRegExp = new RegExp('^https?:/');
export const postGroupResponseDataAttributesMangaUpdatesMax = 128;

export const postGroupResponseDataAttributesMangaUpdatesRegExp = new RegExp('^https:\\/\\/www\\.mangaupdates\\.com\\/(group|publisher)(s\\.html\\?id=\\d+|\\/[\\w-]+\\/?([\\w-]+)?(\\/)?)$');
export const postGroupResponseDataAttributesFocusedLanguageItemRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const postGroupResponseDataAttributesPublishDelayRegExp = new RegExp('^(P([1-9]|[1-9][0-9])D)?(P?([1-9])W)?(P?T(([1-9]|1[0-9]|2[0-4])H)?(([1-9]|[1-5][0-9]|60)M)?(([1-9]|[1-5][0-9]|60)S)?)?$');


export const postGroupResponse = zod.object({
  "result": zod.enum(['ok']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['scanlation_group']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "altNames": zod.array(zod.record(zod.string(), zod.string().regex(postGroupResponseDataAttributesAltNamesItemRegExpOne))).optional(),
  "website": zod.string().nullish(),
  "ircServer": zod.string().nullish(),
  "ircChannel": zod.string().nullish(),
  "discord": zod.string().nullish(),
  "contactEmail": zod.string().nullish(),
  "description": zod.string().nullish(),
  "twitter": zod.string().url().regex(postGroupResponseDataAttributesTwitterRegExp).nullish(),
  "mangaUpdates": zod.string().url().max(postGroupResponseDataAttributesMangaUpdatesMax).regex(postGroupResponseDataAttributesMangaUpdatesRegExp).nullish(),
  "focusedLanguage": zod.array(zod.string().regex(postGroupResponseDataAttributesFocusedLanguageItemRegExp)).nullish(),
  "locked": zod.boolean().optional(),
  "official": zod.boolean().optional(),
  "verified": zod.boolean().optional(),
  "inactive": zod.boolean().optional(),
  "exLicensed": zod.boolean().optional(),
  "publishDelay": zod.string().regex(postGroupResponseDataAttributesPublishDelayRegExp).optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Get Scanlation Group
 */
export const getGroupIdQueryParams = zod.object({
  "includes[]": zod.array(zod.enum(['leader', 'member'])).optional()
})

export const getGroupIdResponseDataAttributesAltNamesItemRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getGroupIdResponseDataAttributesTwitterRegExp = new RegExp('^https?:/');
export const getGroupIdResponseDataAttributesMangaUpdatesMax = 128;

export const getGroupIdResponseDataAttributesMangaUpdatesRegExp = new RegExp('^https:\\/\\/www\\.mangaupdates\\.com\\/(group|publisher)(s\\.html\\?id=\\d+|\\/[\\w-]+\\/?([\\w-]+)?(\\/)?)$');
export const getGroupIdResponseDataAttributesFocusedLanguageItemRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const getGroupIdResponseDataAttributesPublishDelayRegExp = new RegExp('^(P([1-9]|[1-9][0-9])D)?(P?([1-9])W)?(P?T(([1-9]|1[0-9]|2[0-4])H)?(([1-9]|[1-5][0-9]|60)M)?(([1-9]|[1-5][0-9]|60)S)?)?$');


export const getGroupIdResponse = zod.object({
  "result": zod.enum(['ok']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['scanlation_group']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "altNames": zod.array(zod.record(zod.string(), zod.string().regex(getGroupIdResponseDataAttributesAltNamesItemRegExpOne))).optional(),
  "website": zod.string().nullish(),
  "ircServer": zod.string().nullish(),
  "ircChannel": zod.string().nullish(),
  "discord": zod.string().nullish(),
  "contactEmail": zod.string().nullish(),
  "description": zod.string().nullish(),
  "twitter": zod.string().url().regex(getGroupIdResponseDataAttributesTwitterRegExp).nullish(),
  "mangaUpdates": zod.string().url().max(getGroupIdResponseDataAttributesMangaUpdatesMax).regex(getGroupIdResponseDataAttributesMangaUpdatesRegExp).nullish(),
  "focusedLanguage": zod.array(zod.string().regex(getGroupIdResponseDataAttributesFocusedLanguageItemRegExp)).nullish(),
  "locked": zod.boolean().optional(),
  "official": zod.boolean().optional(),
  "verified": zod.boolean().optional(),
  "inactive": zod.boolean().optional(),
  "exLicensed": zod.boolean().optional(),
  "publishDelay": zod.string().regex(getGroupIdResponseDataAttributesPublishDelayRegExp).optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Update Scanlation Group
 */
export const putGroupIdHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const putGroupIdBodyTwitterRegExp = new RegExp('^https?:/');
export const putGroupIdBodyMangaUpdatesMax = 128;

export const putGroupIdBodyMangaUpdatesRegExp = new RegExp('^https:\\/\\/www\\.mangaupdates\\.com\\/(group|publisher)(s\\.html\\?id=\\d+|\\/[\\w-]+\\/?([\\w-]+)?(\\/)?)$');
export const putGroupIdBodyFocusedLanguagesItemRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');


export const putGroupIdBody = zod.object({
  "name": zod.string().optional(),
  "leader": zod.string().uuid().optional(),
  "members": zod.array(zod.string().uuid()).optional(),
  "website": zod.string().nullish(),
  "ircServer": zod.string().nullish(),
  "ircChannel": zod.string().nullish(),
  "discord": zod.string().nullish(),
  "contactEmail": zod.string().nullish(),
  "description": zod.string().nullish(),
  "twitter": zod.string().url().regex(putGroupIdBodyTwitterRegExp).nullish(),
  "mangaUpdates": zod.string().url().max(putGroupIdBodyMangaUpdatesMax).regex(putGroupIdBodyMangaUpdatesRegExp).nullish(),
  "focusedLanguages": zod.array(zod.string().regex(putGroupIdBodyFocusedLanguagesItemRegExp)).nullish(),
  "inactive": zod.boolean().optional(),
  "locked": zod.boolean().optional(),
  "publishDelay": zod.string().optional(),
  "version": zod.number().min(1)
})

export const putGroupIdResponseDataAttributesAltNamesItemRegExpOne = new RegExp('^[a-z]{2,8}$');
export const putGroupIdResponseDataAttributesTwitterRegExp = new RegExp('^https?:/');
export const putGroupIdResponseDataAttributesMangaUpdatesMax = 128;

export const putGroupIdResponseDataAttributesMangaUpdatesRegExp = new RegExp('^https:\\/\\/www\\.mangaupdates\\.com\\/(group|publisher)(s\\.html\\?id=\\d+|\\/[\\w-]+\\/?([\\w-]+)?(\\/)?)$');
export const putGroupIdResponseDataAttributesFocusedLanguageItemRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const putGroupIdResponseDataAttributesPublishDelayRegExp = new RegExp('^(P([1-9]|[1-9][0-9])D)?(P?([1-9])W)?(P?T(([1-9]|1[0-9]|2[0-4])H)?(([1-9]|[1-5][0-9]|60)M)?(([1-9]|[1-5][0-9]|60)S)?)?$');


export const putGroupIdResponse = zod.object({
  "result": zod.enum(['ok']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['scanlation_group']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "altNames": zod.array(zod.record(zod.string(), zod.string().regex(putGroupIdResponseDataAttributesAltNamesItemRegExpOne))).optional(),
  "website": zod.string().nullish(),
  "ircServer": zod.string().nullish(),
  "ircChannel": zod.string().nullish(),
  "discord": zod.string().nullish(),
  "contactEmail": zod.string().nullish(),
  "description": zod.string().nullish(),
  "twitter": zod.string().url().regex(putGroupIdResponseDataAttributesTwitterRegExp).nullish(),
  "mangaUpdates": zod.string().url().max(putGroupIdResponseDataAttributesMangaUpdatesMax).regex(putGroupIdResponseDataAttributesMangaUpdatesRegExp).nullish(),
  "focusedLanguage": zod.array(zod.string().regex(putGroupIdResponseDataAttributesFocusedLanguageItemRegExp)).nullish(),
  "locked": zod.boolean().optional(),
  "official": zod.boolean().optional(),
  "verified": zod.boolean().optional(),
  "inactive": zod.boolean().optional(),
  "exLicensed": zod.boolean().optional(),
  "publishDelay": zod.string().regex(putGroupIdResponseDataAttributesPublishDelayRegExp).optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Delete Scanlation Group
 */
export const deleteGroupIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Follow Scanlation Group
 */
export const postGroupIdFollowResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Unfollow Scanlation Group
 */
export const deleteGroupIdFollowResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Create CustomList
 */
export const postListHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const postListBody = zod.object({
  "name": zod.string(),
  "visibility": zod.enum(['public', 'private']).optional(),
  "manga": zod.array(zod.string().uuid()).optional(),
  "version": zod.number().min(1).optional()
})

export const postListResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['custom_list']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "visibility": zod.enum(['private', 'public']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Get CustomList
 */
export const getListIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['custom_list']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "visibility": zod.enum(['private', 'public']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * The size of the body is limited to 8KB.
 * @summary Update CustomList
 */
export const putListIdHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const putListIdBody = zod.object({
  "name": zod.string().optional(),
  "visibility": zod.enum(['public', 'private']).optional(),
  "manga": zod.array(zod.string().uuid()).optional(),
  "version": zod.number().min(1)
})

export const putListIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['custom_list']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "visibility": zod.enum(['private', 'public']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Delete CustomList
 */
export const deleteListIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * The request body is empty
 * @summary Follow CustomList
 */
export const followListIdHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const followListIdBody = zod.object({

})

export const followListIdResponse = zod.object({
  "result": zod.enum(['ok']).optional()
})


/**
 * The request body is empty
 * @summary Unfollow CustomList
 */
export const unfollowListIdBody = zod.object({

})

export const unfollowListIdResponse = zod.object({
  "result": zod.enum(['ok']).optional()
})


/**
 * @summary Add Manga in CustomList
 */
export const postMangaIdListListIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Remove Manga in CustomList
 */
export const deleteMangaIdListListIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * This will list public and private CustomList
 * @summary Get logged User CustomList list
 */
export const getUserListQueryLimitMin = 0;

export const getUserListQueryLimitMax = 100;
export const getUserListQueryOffsetMin = 0;


export const getUserListQueryParams = zod.object({
  "limit": zod.number().min(getUserListQueryLimitMin).max(getUserListQueryLimitMax).optional(),
  "offset": zod.number().min(getUserListQueryOffsetMin).optional()
})

export const getUserListResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['custom_list']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "visibility": zod.enum(['private', 'public']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * This will list only public CustomList
 * @summary Get User's CustomList list
 */
export const getUserIdListQueryLimitMin = 0;

export const getUserIdListQueryLimitMax = 100;
export const getUserIdListQueryOffsetMin = 0;


export const getUserIdListQueryParams = zod.object({
  "limit": zod.number().min(getUserIdListQueryLimitMin).max(getUserIdListQueryLimitMax).optional(),
  "offset": zod.number().min(getUserIdListQueryOffsetMin).optional()
})

export const getUserIdListResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['custom_list']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "visibility": zod.enum(['private', 'public']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary User list
 */
export const getUserQueryLimitMin = 0;

export const getUserQueryLimitMax = 100;
export const getUserQueryOffsetMin = 0;


export const getUserQueryParams = zod.object({
  "limit": zod.number().min(getUserQueryLimitMin).max(getUserQueryLimitMax).optional(),
  "offset": zod.number().min(getUserQueryOffsetMin).optional(),
  "ids[]": zod.array(zod.string().uuid()).optional(),
  "username": zod.string().optional(),
  "order": zod.object({
  "username": zod.enum(['asc', 'desc']).optional()
}).optional()
})

export const getUserResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['user']).optional(),
  "attributes": zod.object({
  "username": zod.string().optional(),
  "roles": zod.array(zod.string()).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary Get User
 */
export const getUserIdResponse = zod.object({
  "result": zod.enum(['ok']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['user']).optional(),
  "attributes": zod.object({
  "username": zod.string().optional(),
  "roles": zod.array(zod.string()).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @deprecated
 * @summary Delete User
 */
export const deleteUserIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @deprecated
 * @summary Approve User deletion
 */
export const postUserDeleteCodeResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * Chapter list. If you want the Chapters of a given Manga, please check the feed endpoints.
 * @summary Chapter list
 */
export const getChapterQueryLimitMin = 0;

export const getChapterQueryLimitMax = 100;
export const getChapterQueryOffsetMin = 0;
export const getChapterQueryTranslatedLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getChapterQueryOriginalLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getChapterQueryExcludedOriginalLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getChapterQueryCreatedAtSinceRegExp = new RegExp('^\\d{4}-[0-1]\\d-([0-2]\\d|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$');
export const getChapterQueryUpdatedAtSinceRegExp = new RegExp('^\\d{4}-[0-1]\\d-([0-2]\\d|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$');
export const getChapterQueryPublishAtSinceRegExp = new RegExp('^\\d{4}-[0-1]\\d-([0-2]\\d|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$');


export const getChapterQueryParams = zod.object({
  "limit": zod.number().min(getChapterQueryLimitMin).max(getChapterQueryLimitMax).optional(),
  "offset": zod.number().min(getChapterQueryOffsetMin).optional(),
  "ids[]": zod.array(zod.string().uuid()).optional(),
  "title": zod.string().optional(),
  "groups[]": zod.array(zod.string().uuid()).optional(),
  "uploader": zod.string().uuid().or(zod.array(zod.string().uuid())).optional(),
  "manga": zod.string().uuid().optional(),
  "volume[]": zod.string().or(zod.array(zod.string())).optional(),
  "chapter": zod.string().or(zod.array(zod.string())).optional(),
  "translatedLanguage[]": zod.array(zod.string().regex(getChapterQueryTranslatedLanguageItemRegExp)).optional(),
  "originalLanguage[]": zod.array(zod.string().regex(getChapterQueryOriginalLanguageItemRegExp)).optional(),
  "excludedOriginalLanguage[]": zod.array(zod.string().regex(getChapterQueryExcludedOriginalLanguageItemRegExp)).optional(),
  "contentRating[]": zod.array(zod.enum(['safe', 'suggestive', 'erotica', 'pornographic'])).optional(),
  "excludedGroups[]": zod.array(zod.string().uuid()).optional(),
  "excludedUploaders[]": zod.array(zod.string().uuid()).optional(),
  "includeFutureUpdates": zod.enum(['0', '1']).optional(),
  "includeEmptyPages": zod.number().optional(),
  "includeFuturePublishAt": zod.number().optional(),
  "includeExternalUrl": zod.number().optional(),
  "createdAtSince": zod.string().regex(getChapterQueryCreatedAtSinceRegExp).optional(),
  "updatedAtSince": zod.string().regex(getChapterQueryUpdatedAtSinceRegExp).optional(),
  "publishAtSince": zod.string().regex(getChapterQueryPublishAtSinceRegExp).optional(),
  "order": zod.object({
  "createdAt": zod.enum(['asc', 'desc']).optional(),
  "updatedAt": zod.enum(['asc', 'desc']).optional(),
  "publishAt": zod.enum(['asc', 'desc']).optional(),
  "readableAt": zod.enum(['asc', 'desc']).optional(),
  "volume": zod.enum(['asc', 'desc']).optional(),
  "chapter": zod.enum(['asc', 'desc']).optional()
}).optional(),
  "includes": zod.array(zod.enum(['manga', 'scanlation_group', 'user'])).optional()
})

export const getChapterResponseDataItemAttributesTitleMax = 255;
export const getChapterResponseDataItemAttributesChapterMax = 8;
export const getChapterResponseDataItemAttributesTranslatedLanguageRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const getChapterResponseDataItemAttributesExternalUrlMax = 512;

export const getChapterResponseDataItemAttributesExternalUrlRegExp = new RegExp('^https?:/');


export const getChapterResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['chapter']).optional(),
  "attributes": zod.object({
  "title": zod.string().max(getChapterResponseDataItemAttributesTitleMax).nullish(),
  "volume": zod.string().nullish(),
  "chapter": zod.string().max(getChapterResponseDataItemAttributesChapterMax).nullish(),
  "pages": zod.number().optional(),
  "translatedLanguage": zod.string().regex(getChapterResponseDataItemAttributesTranslatedLanguageRegExp).optional(),
  "uploader": zod.string().uuid().optional(),
  "externalUrl": zod.string().max(getChapterResponseDataItemAttributesExternalUrlMax).regex(getChapterResponseDataItemAttributesExternalUrlRegExp).nullish(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional(),
  "publishAt": zod.string().optional(),
  "readableAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary Get Chapter
 */
export const getChapterIdQueryParams = zod.object({
  "includes[]": zod.array(zod.enum(['manga', 'scanlation_group', 'user'])).optional()
})

export const getChapterIdResponseDataAttributesTitleMax = 255;
export const getChapterIdResponseDataAttributesChapterMax = 8;
export const getChapterIdResponseDataAttributesTranslatedLanguageRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const getChapterIdResponseDataAttributesExternalUrlMax = 512;

export const getChapterIdResponseDataAttributesExternalUrlRegExp = new RegExp('^https?:/');


export const getChapterIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['chapter']).optional(),
  "attributes": zod.object({
  "title": zod.string().max(getChapterIdResponseDataAttributesTitleMax).nullish(),
  "volume": zod.string().nullish(),
  "chapter": zod.string().max(getChapterIdResponseDataAttributesChapterMax).nullish(),
  "pages": zod.number().optional(),
  "translatedLanguage": zod.string().regex(getChapterIdResponseDataAttributesTranslatedLanguageRegExp).optional(),
  "uploader": zod.string().uuid().optional(),
  "externalUrl": zod.string().max(getChapterIdResponseDataAttributesExternalUrlMax).regex(getChapterIdResponseDataAttributesExternalUrlRegExp).nullish(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional(),
  "publishAt": zod.string().optional(),
  "readableAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Update Chapter
 */
export const putChapterIdHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const putChapterIdBodyTitleMax = 255;
export const putChapterIdBodyChapterMax = 8;
export const putChapterIdBodyTranslatedLanguageRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const putChapterIdBodyGroupsItemMin = 36;

export const putChapterIdBodyGroupsItemMax = 36;
export const putChapterIdBodyGroupsMax = 10;


export const putChapterIdBody = zod.object({
  "title": zod.string().max(putChapterIdBodyTitleMax).nullish(),
  "volume": zod.string().nullish(),
  "chapter": zod.string().max(putChapterIdBodyChapterMax).nullish(),
  "translatedLanguage": zod.string().regex(putChapterIdBodyTranslatedLanguageRegExp).optional(),
  "groups": zod.array(zod.string().uuid().min(putChapterIdBodyGroupsItemMin).max(putChapterIdBodyGroupsItemMax)).max(putChapterIdBodyGroupsMax).optional(),
  "version": zod.number().min(1).optional()
}).and(zod.any())

export const putChapterIdResponseDataAttributesTitleMax = 255;
export const putChapterIdResponseDataAttributesChapterMax = 8;
export const putChapterIdResponseDataAttributesTranslatedLanguageRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const putChapterIdResponseDataAttributesExternalUrlMax = 512;

export const putChapterIdResponseDataAttributesExternalUrlRegExp = new RegExp('^https?:/');


export const putChapterIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['chapter']).optional(),
  "attributes": zod.object({
  "title": zod.string().max(putChapterIdResponseDataAttributesTitleMax).nullish(),
  "volume": zod.string().nullish(),
  "chapter": zod.string().max(putChapterIdResponseDataAttributesChapterMax).nullish(),
  "pages": zod.number().optional(),
  "translatedLanguage": zod.string().regex(putChapterIdResponseDataAttributesTranslatedLanguageRegExp).optional(),
  "uploader": zod.string().uuid().optional(),
  "externalUrl": zod.string().max(putChapterIdResponseDataAttributesExternalUrlMax).regex(putChapterIdResponseDataAttributesExternalUrlRegExp).nullish(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional(),
  "publishAt": zod.string().optional(),
  "readableAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Delete Chapter
 */
export const deleteChapterIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Get logged User followed Manga feed (Chapter list)
 */
export const getUserFollowsMangaFeedQueryLimitMax = 500;
export const getUserFollowsMangaFeedQueryOffsetMin = 0;
export const getUserFollowsMangaFeedQueryTranslatedLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getUserFollowsMangaFeedQueryOriginalLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getUserFollowsMangaFeedQueryExcludedOriginalLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getUserFollowsMangaFeedQueryCreatedAtSinceRegExp = new RegExp('^\\d{4}-[0-1]\\d-([0-2]\\d|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$');
export const getUserFollowsMangaFeedQueryUpdatedAtSinceRegExp = new RegExp('^\\d{4}-[0-1]\\d-([0-2]\\d|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$');
export const getUserFollowsMangaFeedQueryPublishAtSinceRegExp = new RegExp('^\\d{4}-[0-1]\\d-([0-2]\\d|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$');


export const getUserFollowsMangaFeedQueryParams = zod.object({
  "limit": zod.number().min(1).max(getUserFollowsMangaFeedQueryLimitMax).optional(),
  "offset": zod.number().min(getUserFollowsMangaFeedQueryOffsetMin).optional(),
  "translatedLanguage[]": zod.array(zod.string().regex(getUserFollowsMangaFeedQueryTranslatedLanguageItemRegExp)).optional(),
  "originalLanguage[]": zod.array(zod.string().regex(getUserFollowsMangaFeedQueryOriginalLanguageItemRegExp)).optional(),
  "excludedOriginalLanguage[]": zod.array(zod.string().regex(getUserFollowsMangaFeedQueryExcludedOriginalLanguageItemRegExp)).optional(),
  "contentRating[]": zod.array(zod.enum(['safe', 'suggestive', 'erotica', 'pornographic'])).optional(),
  "excludedGroups[]": zod.array(zod.string().uuid()).optional(),
  "excludedUploaders[]": zod.array(zod.string().uuid()).optional(),
  "includeFutureUpdates": zod.enum(['0', '1']).optional(),
  "createdAtSince": zod.string().regex(getUserFollowsMangaFeedQueryCreatedAtSinceRegExp).optional(),
  "updatedAtSince": zod.string().regex(getUserFollowsMangaFeedQueryUpdatedAtSinceRegExp).optional(),
  "publishAtSince": zod.string().regex(getUserFollowsMangaFeedQueryPublishAtSinceRegExp).optional(),
  "order": zod.object({
  "createdAt": zod.enum(['asc', 'desc']).optional(),
  "updatedAt": zod.enum(['asc', 'desc']).optional(),
  "publishAt": zod.enum(['asc', 'desc']).optional(),
  "readableAt": zod.enum(['asc', 'desc']).optional(),
  "volume": zod.enum(['asc', 'desc']).optional(),
  "chapter": zod.enum(['asc', 'desc']).optional()
}).optional(),
  "includes[]": zod.array(zod.enum(['manga', 'scanlation_group', 'user'])).optional(),
  "includeEmptyPages": zod.number().optional(),
  "includeFuturePublishAt": zod.number().optional(),
  "includeExternalUrl": zod.number().optional()
})

export const getUserFollowsMangaFeedResponseDataItemAttributesTitleMax = 255;
export const getUserFollowsMangaFeedResponseDataItemAttributesChapterMax = 8;
export const getUserFollowsMangaFeedResponseDataItemAttributesTranslatedLanguageRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const getUserFollowsMangaFeedResponseDataItemAttributesExternalUrlMax = 512;

export const getUserFollowsMangaFeedResponseDataItemAttributesExternalUrlRegExp = new RegExp('^https?:/');


export const getUserFollowsMangaFeedResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['chapter']).optional(),
  "attributes": zod.object({
  "title": zod.string().max(getUserFollowsMangaFeedResponseDataItemAttributesTitleMax).nullish(),
  "volume": zod.string().nullish(),
  "chapter": zod.string().max(getUserFollowsMangaFeedResponseDataItemAttributesChapterMax).nullish(),
  "pages": zod.number().optional(),
  "translatedLanguage": zod.string().regex(getUserFollowsMangaFeedResponseDataItemAttributesTranslatedLanguageRegExp).optional(),
  "uploader": zod.string().uuid().optional(),
  "externalUrl": zod.string().max(getUserFollowsMangaFeedResponseDataItemAttributesExternalUrlMax).regex(getUserFollowsMangaFeedResponseDataItemAttributesExternalUrlRegExp).nullish(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional(),
  "publishAt": zod.string().optional(),
  "readableAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary CustomList Manga feed
 */
export const getListIdFeedQueryLimitMax = 500;
export const getListIdFeedQueryOffsetMin = 0;
export const getListIdFeedQueryTranslatedLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getListIdFeedQueryOriginalLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getListIdFeedQueryExcludedOriginalLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getListIdFeedQueryCreatedAtSinceRegExp = new RegExp('^\\d{4}-[0-1]\\d-([0-2]\\d|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$');
export const getListIdFeedQueryUpdatedAtSinceRegExp = new RegExp('^\\d{4}-[0-1]\\d-([0-2]\\d|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$');
export const getListIdFeedQueryPublishAtSinceRegExp = new RegExp('^\\d{4}-[0-1]\\d-([0-2]\\d|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$');


export const getListIdFeedQueryParams = zod.object({
  "limit": zod.number().min(1).max(getListIdFeedQueryLimitMax).optional(),
  "offset": zod.number().min(getListIdFeedQueryOffsetMin).optional(),
  "translatedLanguage[]": zod.array(zod.string().regex(getListIdFeedQueryTranslatedLanguageItemRegExp)).optional(),
  "originalLanguage[]": zod.array(zod.string().regex(getListIdFeedQueryOriginalLanguageItemRegExp)).optional(),
  "excludedOriginalLanguage[]": zod.array(zod.string().regex(getListIdFeedQueryExcludedOriginalLanguageItemRegExp)).optional(),
  "contentRating[]": zod.array(zod.enum(['safe', 'suggestive', 'erotica', 'pornographic'])).optional(),
  "excludedGroups[]": zod.array(zod.string().uuid()).optional(),
  "excludedUploaders[]": zod.array(zod.string().uuid()).optional(),
  "includeFutureUpdates": zod.enum(['0', '1']).optional(),
  "createdAtSince": zod.string().regex(getListIdFeedQueryCreatedAtSinceRegExp).optional(),
  "updatedAtSince": zod.string().regex(getListIdFeedQueryUpdatedAtSinceRegExp).optional(),
  "publishAtSince": zod.string().regex(getListIdFeedQueryPublishAtSinceRegExp).optional(),
  "order": zod.object({
  "createdAt": zod.enum(['asc', 'desc']).optional(),
  "updatedAt": zod.enum(['asc', 'desc']).optional(),
  "publishAt": zod.enum(['asc', 'desc']).optional(),
  "readableAt": zod.enum(['asc', 'desc']).optional(),
  "volume": zod.enum(['asc', 'desc']).optional(),
  "chapter": zod.enum(['asc', 'desc']).optional()
}).optional(),
  "includes[]": zod.array(zod.enum(['manga', 'scanlation_group', 'user'])).optional(),
  "includeEmptyPages": zod.number().optional(),
  "includeFuturePublishAt": zod.number().optional(),
  "includeExternalUrl": zod.number().optional()
})

export const getListIdFeedResponseDataItemAttributesTitleMax = 255;
export const getListIdFeedResponseDataItemAttributesChapterMax = 8;
export const getListIdFeedResponseDataItemAttributesTranslatedLanguageRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const getListIdFeedResponseDataItemAttributesExternalUrlMax = 512;

export const getListIdFeedResponseDataItemAttributesExternalUrlRegExp = new RegExp('^https?:/');


export const getListIdFeedResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['chapter']).optional(),
  "attributes": zod.object({
  "title": zod.string().max(getListIdFeedResponseDataItemAttributesTitleMax).nullish(),
  "volume": zod.string().nullish(),
  "chapter": zod.string().max(getListIdFeedResponseDataItemAttributesChapterMax).nullish(),
  "pages": zod.number().optional(),
  "translatedLanguage": zod.string().regex(getListIdFeedResponseDataItemAttributesTranslatedLanguageRegExp).optional(),
  "uploader": zod.string().uuid().optional(),
  "externalUrl": zod.string().max(getListIdFeedResponseDataItemAttributesExternalUrlMax).regex(getListIdFeedResponseDataItemAttributesExternalUrlRegExp).nullish(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional(),
  "publishAt": zod.string().optional(),
  "readableAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary Unfollow Manga
 */
export const deleteMangaIdFollowResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Follow Manga
 */
export const postMangaIdFollowResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary CoverArt list
 */
export const getCoverQueryLimitMin = 0;

export const getCoverQueryLimitMax = 100;
export const getCoverQueryOffsetMin = 0;
export const getCoverQueryLocalesItemRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');


export const getCoverQueryParams = zod.object({
  "limit": zod.number().min(getCoverQueryLimitMin).max(getCoverQueryLimitMax).optional(),
  "offset": zod.number().min(getCoverQueryOffsetMin).optional(),
  "manga[]": zod.array(zod.string().uuid()).optional(),
  "ids[]": zod.array(zod.string().uuid()).optional(),
  "uploaders[]": zod.array(zod.string().uuid()).optional(),
  "locales[]": zod.array(zod.string().regex(getCoverQueryLocalesItemRegExp)).optional(),
  "order": zod.object({
  "createdAt": zod.enum(['asc', 'desc']).optional(),
  "updatedAt": zod.enum(['asc', 'desc']).optional(),
  "volume": zod.enum(['asc', 'desc']).optional()
}).optional(),
  "includes[]": zod.array(zod.enum(['manga', 'user'])).optional()
})

export const getCoverResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['cover_art']).optional(),
  "attributes": zod.object({
  "volume": zod.string().nullish(),
  "fileName": zod.string().optional(),
  "description": zod.string().nullish(),
  "locale": zod.string().nullish(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary Upload Cover
 */
export const uploadCoverHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const uploadCoverResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['cover_art']).optional(),
  "attributes": zod.object({
  "volume": zod.string().nullish(),
  "fileName": zod.string().optional(),
  "description": zod.string().nullish(),
  "locale": zod.string().nullish(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Get Cover
 */
export const getCoverIdQueryParams = zod.object({
  "includes[]": zod.array(zod.enum(['manga', 'user'])).optional()
})

export const getCoverIdResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['cover_art']).optional(),
  "attributes": zod.object({
  "volume": zod.string().nullish(),
  "fileName": zod.string().optional(),
  "description": zod.string().nullish(),
  "locale": zod.string().nullish(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Edit Cover
 */
export const editCoverHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const editCoverBodyVolumeMin = 0;

export const editCoverBodyVolumeMax = 8;
export const editCoverBodyDescriptionMin = 0;

export const editCoverBodyDescriptionMax = 512;
export const editCoverBodyLocaleRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');


export const editCoverBody = zod.object({
  "volume": zod.string().min(editCoverBodyVolumeMin).max(editCoverBodyVolumeMax).nullable(),
  "description": zod.string().min(editCoverBodyDescriptionMin).max(editCoverBodyDescriptionMax).nullish(),
  "locale": zod.string().regex(editCoverBodyLocaleRegExp).nullish(),
  "version": zod.number().min(1)
})

export const editCoverResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['cover_art']).optional(),
  "attributes": zod.object({
  "volume": zod.string().nullish(),
  "fileName": zod.string().optional(),
  "description": zod.string().nullish(),
  "locale": zod.string().nullish(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Delete Cover
 */
export const deleteCoverResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Author list
 */
export const getAuthorQueryLimitMin = 0;

export const getAuthorQueryLimitMax = 100;
export const getAuthorQueryOffsetMin = 0;


export const getAuthorQueryParams = zod.object({
  "limit": zod.number().min(getAuthorQueryLimitMin).max(getAuthorQueryLimitMax).optional(),
  "offset": zod.number().min(getAuthorQueryOffsetMin).optional(),
  "ids[]": zod.array(zod.string().uuid()).optional(),
  "name": zod.string().optional(),
  "order": zod.object({
  "name": zod.enum(['asc', 'desc']).optional()
}).optional(),
  "includes[]": zod.array(zod.enum(['manga'])).optional()
})

export const getAuthorResponseDataItemAttributesBiographyRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getAuthorResponseDataItemAttributesTwitterRegExp = new RegExp('^https?://twitter\\.com(/|$)');
export const getAuthorResponseDataItemAttributesPixivRegExp = new RegExp('^https?://([\\w-]+\\.)?pixiv\\.net(/|$)');
export const getAuthorResponseDataItemAttributesMelonBookRegExp = new RegExp('^https?://([\\w-]+\\.)?melonbooks\\.co\\.jp(/|$)');
export const getAuthorResponseDataItemAttributesFanBoxRegExp = new RegExp('^https?://([\\w-]+\\.)?fanbox\\.cc(/|$)');
export const getAuthorResponseDataItemAttributesBoothRegExp = new RegExp('^https?://([\\w-]+\\.)?booth\\.pm(/|$)');
export const getAuthorResponseDataItemAttributesNicoVideoRegExp = new RegExp('^https?://([\\w-]+\\.)?nicovideo\\.jp(/|$)');
export const getAuthorResponseDataItemAttributesSkebRegExp = new RegExp('^https?://([\\w-]+\\.)?skeb\\.jp(/|$)');
export const getAuthorResponseDataItemAttributesFantiaRegExp = new RegExp('^https?://([\\w-]+\\.)?fantia\\.jp(/|$)');
export const getAuthorResponseDataItemAttributesTumblrRegExp = new RegExp('^https?://([\\w-]+\\.)?tumblr\\.com(/|$)');
export const getAuthorResponseDataItemAttributesYoutubeRegExp = new RegExp('^https?://www\\.youtube\\.com(/|$)');
export const getAuthorResponseDataItemAttributesWeiboRegExp = new RegExp('^https?://([\\w-]+\\.)?weibo\\.(cn|com)(/|$)');
export const getAuthorResponseDataItemAttributesNaverRegExp = new RegExp('^https?://([\\w-]+\\.)?naver\\.com(/|$)');
export const getAuthorResponseDataItemAttributesNamicomiRegExp = new RegExp('^https?://([\\w-]+\\.)?namicomi\\.com(/|$)');
export const getAuthorResponseDataItemAttributesWebsiteRegExp = new RegExp('^https?:/');


export const getAuthorResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['author']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "imageUrl": zod.string().nullish(),
  "biography": zod.record(zod.string(), zod.string().regex(getAuthorResponseDataItemAttributesBiographyRegExpOne)).optional(),
  "twitter": zod.string().url().regex(getAuthorResponseDataItemAttributesTwitterRegExp).nullish(),
  "pixiv": zod.string().url().regex(getAuthorResponseDataItemAttributesPixivRegExp).nullish(),
  "melonBook": zod.string().url().regex(getAuthorResponseDataItemAttributesMelonBookRegExp).nullish(),
  "fanBox": zod.string().url().regex(getAuthorResponseDataItemAttributesFanBoxRegExp).nullish(),
  "booth": zod.string().url().regex(getAuthorResponseDataItemAttributesBoothRegExp).nullish(),
  "nicoVideo": zod.string().url().regex(getAuthorResponseDataItemAttributesNicoVideoRegExp).nullish(),
  "skeb": zod.string().url().regex(getAuthorResponseDataItemAttributesSkebRegExp).nullish(),
  "fantia": zod.string().url().regex(getAuthorResponseDataItemAttributesFantiaRegExp).nullish(),
  "tumblr": zod.string().url().regex(getAuthorResponseDataItemAttributesTumblrRegExp).nullish(),
  "youtube": zod.string().url().regex(getAuthorResponseDataItemAttributesYoutubeRegExp).nullish(),
  "weibo": zod.string().url().regex(getAuthorResponseDataItemAttributesWeiboRegExp).nullish(),
  "naver": zod.string().url().regex(getAuthorResponseDataItemAttributesNaverRegExp).nullish(),
  "namicomi": zod.string().url().regex(getAuthorResponseDataItemAttributesNamicomiRegExp).nullish(),
  "website": zod.string().url().regex(getAuthorResponseDataItemAttributesWebsiteRegExp).nullish(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary Create Author
 */
export const postAuthorHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const postAuthorBodyBiographyRegExpOne = new RegExp('^[a-z]{2,8}$');
export const postAuthorBodyTwitterRegExp = new RegExp('^https?://twitter\\.com(/|$)');
export const postAuthorBodyPixivRegExp = new RegExp('^https?://([\\w-]+\\.)?pixiv\\.net(/|$)');
export const postAuthorBodyMelonBookRegExp = new RegExp('^https?://([\\w-]+\\.)?melonbooks\\.co\\.jp(/|$)');
export const postAuthorBodyFanBoxRegExp = new RegExp('^https?://([\\w-]+\\.)?fanbox\\.cc(/|$)');
export const postAuthorBodyBoothRegExp = new RegExp('^https?://([\\w-]+\\.)?booth\\.pm(/|$)');
export const postAuthorBodyNicoVideoRegExp = new RegExp('^https?://([\\w-]+\\.)?nicovideo\\.jp(/|$)');
export const postAuthorBodySkebRegExp = new RegExp('^https?://([\\w-]+\\.)?skeb\\.jp(/|$)');
export const postAuthorBodyFantiaRegExp = new RegExp('^https?://([\\w-]+\\.)?fantia\\.jp(/|$)');
export const postAuthorBodyTumblrRegExp = new RegExp('^https?://([\\w-]+\\.)?tumblr\\.com(/|$)');
export const postAuthorBodyYoutubeRegExp = new RegExp('^https?://www\\.youtube\\.com(/|$)');
export const postAuthorBodyWeiboRegExp = new RegExp('^https?://([\\w-]+\\.)?weibo\\.(cn|com)(/|$)');
export const postAuthorBodyNaverRegExp = new RegExp('^https?://([\\w-]+\\.)?naver\\.com(/|$)');
export const postAuthorBodyWebsiteRegExp = new RegExp('^https?:/');


export const postAuthorBody = zod.object({
  "name": zod.string(),
  "biography": zod.record(zod.string(), zod.string().regex(postAuthorBodyBiographyRegExpOne)).optional(),
  "twitter": zod.string().url().regex(postAuthorBodyTwitterRegExp).nullish(),
  "pixiv": zod.string().url().regex(postAuthorBodyPixivRegExp).nullish(),
  "melonBook": zod.string().url().regex(postAuthorBodyMelonBookRegExp).nullish(),
  "fanBox": zod.string().url().regex(postAuthorBodyFanBoxRegExp).nullish(),
  "booth": zod.string().url().regex(postAuthorBodyBoothRegExp).nullish(),
  "nicoVideo": zod.string().url().regex(postAuthorBodyNicoVideoRegExp).nullish(),
  "skeb": zod.string().url().regex(postAuthorBodySkebRegExp).nullish(),
  "fantia": zod.string().url().regex(postAuthorBodyFantiaRegExp).nullish(),
  "tumblr": zod.string().url().regex(postAuthorBodyTumblrRegExp).nullish(),
  "youtube": zod.string().url().regex(postAuthorBodyYoutubeRegExp).nullish(),
  "weibo": zod.string().url().regex(postAuthorBodyWeiboRegExp).nullish(),
  "naver": zod.string().url().regex(postAuthorBodyNaverRegExp).nullish(),
  "website": zod.string().url().regex(postAuthorBodyWebsiteRegExp).nullish()
})

export const postAuthorResponseDataAttributesBiographyRegExpOne = new RegExp('^[a-z]{2,8}$');
export const postAuthorResponseDataAttributesTwitterRegExp = new RegExp('^https?://twitter\\.com(/|$)');
export const postAuthorResponseDataAttributesPixivRegExp = new RegExp('^https?://([\\w-]+\\.)?pixiv\\.net(/|$)');
export const postAuthorResponseDataAttributesMelonBookRegExp = new RegExp('^https?://([\\w-]+\\.)?melonbooks\\.co\\.jp(/|$)');
export const postAuthorResponseDataAttributesFanBoxRegExp = new RegExp('^https?://([\\w-]+\\.)?fanbox\\.cc(/|$)');
export const postAuthorResponseDataAttributesBoothRegExp = new RegExp('^https?://([\\w-]+\\.)?booth\\.pm(/|$)');
export const postAuthorResponseDataAttributesNicoVideoRegExp = new RegExp('^https?://([\\w-]+\\.)?nicovideo\\.jp(/|$)');
export const postAuthorResponseDataAttributesSkebRegExp = new RegExp('^https?://([\\w-]+\\.)?skeb\\.jp(/|$)');
export const postAuthorResponseDataAttributesFantiaRegExp = new RegExp('^https?://([\\w-]+\\.)?fantia\\.jp(/|$)');
export const postAuthorResponseDataAttributesTumblrRegExp = new RegExp('^https?://([\\w-]+\\.)?tumblr\\.com(/|$)');
export const postAuthorResponseDataAttributesYoutubeRegExp = new RegExp('^https?://www\\.youtube\\.com(/|$)');
export const postAuthorResponseDataAttributesWeiboRegExp = new RegExp('^https?://([\\w-]+\\.)?weibo\\.(cn|com)(/|$)');
export const postAuthorResponseDataAttributesNaverRegExp = new RegExp('^https?://([\\w-]+\\.)?naver\\.com(/|$)');
export const postAuthorResponseDataAttributesNamicomiRegExp = new RegExp('^https?://([\\w-]+\\.)?namicomi\\.com(/|$)');
export const postAuthorResponseDataAttributesWebsiteRegExp = new RegExp('^https?:/');


export const postAuthorResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['author']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "imageUrl": zod.string().nullish(),
  "biography": zod.record(zod.string(), zod.string().regex(postAuthorResponseDataAttributesBiographyRegExpOne)).optional(),
  "twitter": zod.string().url().regex(postAuthorResponseDataAttributesTwitterRegExp).nullish(),
  "pixiv": zod.string().url().regex(postAuthorResponseDataAttributesPixivRegExp).nullish(),
  "melonBook": zod.string().url().regex(postAuthorResponseDataAttributesMelonBookRegExp).nullish(),
  "fanBox": zod.string().url().regex(postAuthorResponseDataAttributesFanBoxRegExp).nullish(),
  "booth": zod.string().url().regex(postAuthorResponseDataAttributesBoothRegExp).nullish(),
  "nicoVideo": zod.string().url().regex(postAuthorResponseDataAttributesNicoVideoRegExp).nullish(),
  "skeb": zod.string().url().regex(postAuthorResponseDataAttributesSkebRegExp).nullish(),
  "fantia": zod.string().url().regex(postAuthorResponseDataAttributesFantiaRegExp).nullish(),
  "tumblr": zod.string().url().regex(postAuthorResponseDataAttributesTumblrRegExp).nullish(),
  "youtube": zod.string().url().regex(postAuthorResponseDataAttributesYoutubeRegExp).nullish(),
  "weibo": zod.string().url().regex(postAuthorResponseDataAttributesWeiboRegExp).nullish(),
  "naver": zod.string().url().regex(postAuthorResponseDataAttributesNaverRegExp).nullish(),
  "namicomi": zod.string().url().regex(postAuthorResponseDataAttributesNamicomiRegExp).nullish(),
  "website": zod.string().url().regex(postAuthorResponseDataAttributesWebsiteRegExp).nullish(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Get Author
 */
export const getAuthorIdQueryParams = zod.object({
  "includes[]": zod.array(zod.enum(['manga'])).optional()
})

export const getAuthorIdResponseDataAttributesBiographyRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getAuthorIdResponseDataAttributesTwitterRegExp = new RegExp('^https?://twitter\\.com(/|$)');
export const getAuthorIdResponseDataAttributesPixivRegExp = new RegExp('^https?://([\\w-]+\\.)?pixiv\\.net(/|$)');
export const getAuthorIdResponseDataAttributesMelonBookRegExp = new RegExp('^https?://([\\w-]+\\.)?melonbooks\\.co\\.jp(/|$)');
export const getAuthorIdResponseDataAttributesFanBoxRegExp = new RegExp('^https?://([\\w-]+\\.)?fanbox\\.cc(/|$)');
export const getAuthorIdResponseDataAttributesBoothRegExp = new RegExp('^https?://([\\w-]+\\.)?booth\\.pm(/|$)');
export const getAuthorIdResponseDataAttributesNicoVideoRegExp = new RegExp('^https?://([\\w-]+\\.)?nicovideo\\.jp(/|$)');
export const getAuthorIdResponseDataAttributesSkebRegExp = new RegExp('^https?://([\\w-]+\\.)?skeb\\.jp(/|$)');
export const getAuthorIdResponseDataAttributesFantiaRegExp = new RegExp('^https?://([\\w-]+\\.)?fantia\\.jp(/|$)');
export const getAuthorIdResponseDataAttributesTumblrRegExp = new RegExp('^https?://([\\w-]+\\.)?tumblr\\.com(/|$)');
export const getAuthorIdResponseDataAttributesYoutubeRegExp = new RegExp('^https?://www\\.youtube\\.com(/|$)');
export const getAuthorIdResponseDataAttributesWeiboRegExp = new RegExp('^https?://([\\w-]+\\.)?weibo\\.(cn|com)(/|$)');
export const getAuthorIdResponseDataAttributesNaverRegExp = new RegExp('^https?://([\\w-]+\\.)?naver\\.com(/|$)');
export const getAuthorIdResponseDataAttributesNamicomiRegExp = new RegExp('^https?://([\\w-]+\\.)?namicomi\\.com(/|$)');
export const getAuthorIdResponseDataAttributesWebsiteRegExp = new RegExp('^https?:/');


export const getAuthorIdResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['author']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "imageUrl": zod.string().nullish(),
  "biography": zod.record(zod.string(), zod.string().regex(getAuthorIdResponseDataAttributesBiographyRegExpOne)).optional(),
  "twitter": zod.string().url().regex(getAuthorIdResponseDataAttributesTwitterRegExp).nullish(),
  "pixiv": zod.string().url().regex(getAuthorIdResponseDataAttributesPixivRegExp).nullish(),
  "melonBook": zod.string().url().regex(getAuthorIdResponseDataAttributesMelonBookRegExp).nullish(),
  "fanBox": zod.string().url().regex(getAuthorIdResponseDataAttributesFanBoxRegExp).nullish(),
  "booth": zod.string().url().regex(getAuthorIdResponseDataAttributesBoothRegExp).nullish(),
  "nicoVideo": zod.string().url().regex(getAuthorIdResponseDataAttributesNicoVideoRegExp).nullish(),
  "skeb": zod.string().url().regex(getAuthorIdResponseDataAttributesSkebRegExp).nullish(),
  "fantia": zod.string().url().regex(getAuthorIdResponseDataAttributesFantiaRegExp).nullish(),
  "tumblr": zod.string().url().regex(getAuthorIdResponseDataAttributesTumblrRegExp).nullish(),
  "youtube": zod.string().url().regex(getAuthorIdResponseDataAttributesYoutubeRegExp).nullish(),
  "weibo": zod.string().url().regex(getAuthorIdResponseDataAttributesWeiboRegExp).nullish(),
  "naver": zod.string().url().regex(getAuthorIdResponseDataAttributesNaverRegExp).nullish(),
  "namicomi": zod.string().url().regex(getAuthorIdResponseDataAttributesNamicomiRegExp).nullish(),
  "website": zod.string().url().regex(getAuthorIdResponseDataAttributesWebsiteRegExp).nullish(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Update Author
 */
export const putAuthorIdHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const putAuthorIdBodyBiographyRegExpOne = new RegExp('^[a-z]{2,8}$');
export const putAuthorIdBodyTwitterRegExp = new RegExp('^https?://twitter\\.com(/|$)');
export const putAuthorIdBodyPixivRegExp = new RegExp('^https?://([\\w-]+\\.)?pixiv\\.net(/|$)');
export const putAuthorIdBodyMelonBookRegExp = new RegExp('^https?://([\\w-]+\\.)?melonbooks\\.co\\.jp(/|$)');
export const putAuthorIdBodyFanBoxRegExp = new RegExp('^https?://([\\w-]+\\.)?fanbox\\.cc(/|$)');
export const putAuthorIdBodyBoothRegExp = new RegExp('^https?://([\\w-]+\\.)?booth\\.pm(/|$)');
export const putAuthorIdBodyNicoVideoRegExp = new RegExp('^https?://([\\w-]+\\.)?nicovideo\\.jp(/|$)');
export const putAuthorIdBodySkebRegExp = new RegExp('^https?://([\\w-]+\\.)?skeb\\.jp(/|$)');
export const putAuthorIdBodyFantiaRegExp = new RegExp('^https?://([\\w-]+\\.)?fantia\\.jp(/|$)');
export const putAuthorIdBodyTumblrRegExp = new RegExp('^https?://([\\w-]+\\.)?tumblr\\.com(/|$)');
export const putAuthorIdBodyYoutubeRegExp = new RegExp('^https?://www\\.youtube\\.com(/|$)');
export const putAuthorIdBodyWeiboRegExp = new RegExp('^https?://([\\w-]+\\.)?weibo\\.(cn|com)(/|$)');
export const putAuthorIdBodyNaverRegExp = new RegExp('^https?://([\\w-]+\\.)?naver\\.com(/|$)');
export const putAuthorIdBodyWebsiteRegExp = new RegExp('^https?:/');


export const putAuthorIdBody = zod.object({
  "name": zod.string().optional(),
  "biography": zod.record(zod.string(), zod.string().regex(putAuthorIdBodyBiographyRegExpOne)).optional(),
  "twitter": zod.string().url().regex(putAuthorIdBodyTwitterRegExp).nullish(),
  "pixiv": zod.string().url().regex(putAuthorIdBodyPixivRegExp).nullish(),
  "melonBook": zod.string().url().regex(putAuthorIdBodyMelonBookRegExp).nullish(),
  "fanBox": zod.string().url().regex(putAuthorIdBodyFanBoxRegExp).nullish(),
  "booth": zod.string().url().regex(putAuthorIdBodyBoothRegExp).nullish(),
  "nicoVideo": zod.string().url().regex(putAuthorIdBodyNicoVideoRegExp).nullish(),
  "skeb": zod.string().url().regex(putAuthorIdBodySkebRegExp).nullish(),
  "fantia": zod.string().url().regex(putAuthorIdBodyFantiaRegExp).nullish(),
  "tumblr": zod.string().url().regex(putAuthorIdBodyTumblrRegExp).nullish(),
  "youtube": zod.string().url().regex(putAuthorIdBodyYoutubeRegExp).nullish(),
  "weibo": zod.string().url().regex(putAuthorIdBodyWeiboRegExp).nullish(),
  "naver": zod.string().url().regex(putAuthorIdBodyNaverRegExp).nullish(),
  "website": zod.string().url().regex(putAuthorIdBodyWebsiteRegExp).nullish(),
  "version": zod.number().min(1)
})

export const putAuthorIdResponseDataAttributesBiographyRegExpOne = new RegExp('^[a-z]{2,8}$');
export const putAuthorIdResponseDataAttributesTwitterRegExp = new RegExp('^https?://twitter\\.com(/|$)');
export const putAuthorIdResponseDataAttributesPixivRegExp = new RegExp('^https?://([\\w-]+\\.)?pixiv\\.net(/|$)');
export const putAuthorIdResponseDataAttributesMelonBookRegExp = new RegExp('^https?://([\\w-]+\\.)?melonbooks\\.co\\.jp(/|$)');
export const putAuthorIdResponseDataAttributesFanBoxRegExp = new RegExp('^https?://([\\w-]+\\.)?fanbox\\.cc(/|$)');
export const putAuthorIdResponseDataAttributesBoothRegExp = new RegExp('^https?://([\\w-]+\\.)?booth\\.pm(/|$)');
export const putAuthorIdResponseDataAttributesNicoVideoRegExp = new RegExp('^https?://([\\w-]+\\.)?nicovideo\\.jp(/|$)');
export const putAuthorIdResponseDataAttributesSkebRegExp = new RegExp('^https?://([\\w-]+\\.)?skeb\\.jp(/|$)');
export const putAuthorIdResponseDataAttributesFantiaRegExp = new RegExp('^https?://([\\w-]+\\.)?fantia\\.jp(/|$)');
export const putAuthorIdResponseDataAttributesTumblrRegExp = new RegExp('^https?://([\\w-]+\\.)?tumblr\\.com(/|$)');
export const putAuthorIdResponseDataAttributesYoutubeRegExp = new RegExp('^https?://www\\.youtube\\.com(/|$)');
export const putAuthorIdResponseDataAttributesWeiboRegExp = new RegExp('^https?://([\\w-]+\\.)?weibo\\.(cn|com)(/|$)');
export const putAuthorIdResponseDataAttributesNaverRegExp = new RegExp('^https?://([\\w-]+\\.)?naver\\.com(/|$)');
export const putAuthorIdResponseDataAttributesNamicomiRegExp = new RegExp('^https?://([\\w-]+\\.)?namicomi\\.com(/|$)');
export const putAuthorIdResponseDataAttributesWebsiteRegExp = new RegExp('^https?:/');


export const putAuthorIdResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['author']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "imageUrl": zod.string().nullish(),
  "biography": zod.record(zod.string(), zod.string().regex(putAuthorIdResponseDataAttributesBiographyRegExpOne)).optional(),
  "twitter": zod.string().url().regex(putAuthorIdResponseDataAttributesTwitterRegExp).nullish(),
  "pixiv": zod.string().url().regex(putAuthorIdResponseDataAttributesPixivRegExp).nullish(),
  "melonBook": zod.string().url().regex(putAuthorIdResponseDataAttributesMelonBookRegExp).nullish(),
  "fanBox": zod.string().url().regex(putAuthorIdResponseDataAttributesFanBoxRegExp).nullish(),
  "booth": zod.string().url().regex(putAuthorIdResponseDataAttributesBoothRegExp).nullish(),
  "nicoVideo": zod.string().url().regex(putAuthorIdResponseDataAttributesNicoVideoRegExp).nullish(),
  "skeb": zod.string().url().regex(putAuthorIdResponseDataAttributesSkebRegExp).nullish(),
  "fantia": zod.string().url().regex(putAuthorIdResponseDataAttributesFantiaRegExp).nullish(),
  "tumblr": zod.string().url().regex(putAuthorIdResponseDataAttributesTumblrRegExp).nullish(),
  "youtube": zod.string().url().regex(putAuthorIdResponseDataAttributesYoutubeRegExp).nullish(),
  "weibo": zod.string().url().regex(putAuthorIdResponseDataAttributesWeiboRegExp).nullish(),
  "naver": zod.string().url().regex(putAuthorIdResponseDataAttributesNaverRegExp).nullish(),
  "namicomi": zod.string().url().regex(putAuthorIdResponseDataAttributesNamicomiRegExp).nullish(),
  "website": zod.string().url().regex(putAuthorIdResponseDataAttributesWebsiteRegExp).nullish(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Delete Author
 */
export const deleteAuthorIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Legacy ID mapping
 */
export const postLegacyMappingHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const postLegacyMappingBody = zod.object({
  "type": zod.enum(['group', 'manga', 'chapter', 'tag']).optional(),
  "ids": zod.array(zod.number()).optional()
})

export const postLegacyMappingResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['mapping_id']).optional(),
  "attributes": zod.object({
  "type": zod.enum(['manga', 'chapter', 'group', 'tag']).optional(),
  "legacyId": zod.number().optional(),
  "newId": zod.string().uuid().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary Manga feed
 */
export const getMangaIdFeedQueryLimitMax = 500;
export const getMangaIdFeedQueryOffsetMin = 0;
export const getMangaIdFeedQueryTranslatedLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getMangaIdFeedQueryOriginalLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getMangaIdFeedQueryExcludedOriginalLanguageItemRegExp = new RegExp('^[a-zA-Z\\-]{2,5}$');
export const getMangaIdFeedQueryCreatedAtSinceRegExp = new RegExp('^\\d{4}-[0-1]\\d-([0-2]\\d|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$');
export const getMangaIdFeedQueryUpdatedAtSinceRegExp = new RegExp('^\\d{4}-[0-1]\\d-([0-2]\\d|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$');
export const getMangaIdFeedQueryPublishAtSinceRegExp = new RegExp('^\\d{4}-[0-1]\\d-([0-2]\\d|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$');


export const getMangaIdFeedQueryParams = zod.object({
  "limit": zod.number().min(1).max(getMangaIdFeedQueryLimitMax).optional(),
  "offset": zod.number().min(getMangaIdFeedQueryOffsetMin).optional(),
  "translatedLanguage[]": zod.array(zod.string().regex(getMangaIdFeedQueryTranslatedLanguageItemRegExp)).optional(),
  "originalLanguage[]": zod.array(zod.string().regex(getMangaIdFeedQueryOriginalLanguageItemRegExp)).optional(),
  "excludedOriginalLanguage[]": zod.array(zod.string().regex(getMangaIdFeedQueryExcludedOriginalLanguageItemRegExp)).optional(),
  "contentRating[]": zod.array(zod.enum(['safe', 'suggestive', 'erotica', 'pornographic'])).optional(),
  "excludedGroups[]": zod.array(zod.string().uuid()).optional(),
  "excludedUploaders[]": zod.array(zod.string().uuid()).optional(),
  "includeFutureUpdates": zod.enum(['0', '1']).optional(),
  "createdAtSince": zod.string().regex(getMangaIdFeedQueryCreatedAtSinceRegExp).optional(),
  "updatedAtSince": zod.string().regex(getMangaIdFeedQueryUpdatedAtSinceRegExp).optional(),
  "publishAtSince": zod.string().regex(getMangaIdFeedQueryPublishAtSinceRegExp).optional(),
  "order": zod.object({
  "createdAt": zod.enum(['asc', 'desc']).optional(),
  "updatedAt": zod.enum(['asc', 'desc']).optional(),
  "publishAt": zod.enum(['asc', 'desc']).optional(),
  "readableAt": zod.enum(['asc', 'desc']).optional(),
  "volume": zod.enum(['asc', 'desc']).optional(),
  "chapter": zod.enum(['asc', 'desc']).optional()
}).optional(),
  "includes[]": zod.array(zod.enum(['manga', 'scanlation_group', 'user'])).optional(),
  "includeEmptyPages": zod.number().optional(),
  "includeFuturePublishAt": zod.number().optional(),
  "includeExternalUrl": zod.number().optional()
})

export const getMangaIdFeedResponseDataItemAttributesTitleMax = 255;
export const getMangaIdFeedResponseDataItemAttributesChapterMax = 8;
export const getMangaIdFeedResponseDataItemAttributesTranslatedLanguageRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const getMangaIdFeedResponseDataItemAttributesExternalUrlMax = 512;

export const getMangaIdFeedResponseDataItemAttributesExternalUrlRegExp = new RegExp('^https?:/');


export const getMangaIdFeedResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['chapter']).optional(),
  "attributes": zod.object({
  "title": zod.string().max(getMangaIdFeedResponseDataItemAttributesTitleMax).nullish(),
  "volume": zod.string().nullish(),
  "chapter": zod.string().max(getMangaIdFeedResponseDataItemAttributesChapterMax).nullish(),
  "pages": zod.number().optional(),
  "translatedLanguage": zod.string().regex(getMangaIdFeedResponseDataItemAttributesTranslatedLanguageRegExp).optional(),
  "uploader": zod.string().uuid().optional(),
  "externalUrl": zod.string().max(getMangaIdFeedResponseDataItemAttributesExternalUrlMax).regex(getMangaIdFeedResponseDataItemAttributesExternalUrlRegExp).nullish(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional(),
  "publishAt": zod.string().optional(),
  "readableAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * A list of chapter ids that are marked as read for the specified manga
 * @summary Manga read markers
 */
export const getMangaChapterReadmarkersResponse = zod.object({
  "result": zod.enum(['ok']).optional(),
  "data": zod.array(zod.string().uuid()).optional()
})


/**
 * Send a lot of chapter ids for one manga to mark as read and/or unread
 * @summary Manga read markers batch
 */
export const postMangaChapterReadmarkersQueryParams = zod.object({
  "updateHistory": zod.boolean().optional()
})

export const postMangaChapterReadmarkersBody = zod.any().or(zod.any())

export const postMangaChapterReadmarkersResponse = zod.object({
  "result": zod.enum(['ok']).optional()
})


/**
 * A list of chapter ids that are marked as read for the given manga ids
 * @summary Manga read markers
 */
export const getMangaChapterReadmarkers2QueryParams = zod.object({
  "ids[]": zod.array(zod.string().uuid()),
  "grouped": zod.boolean().optional()
})

export const getMangaChapterReadmarkers2Response = zod.object({
  "result": zod.enum(['ok']).optional(),
  "data": zod.array(zod.string().uuid()).or(zod.record(zod.string(), zod.array(zod.string().uuid()))).optional()
})


/**
 * @summary Get a random Manga
 */
export const getMangaRandomQueryParams = zod.object({
  "includes[]": zod.array(zod.enum(['manga', 'cover_art', 'author', 'artist', 'tag', 'creator'])).optional(),
  "contentRating[]": zod.array(zod.enum(['safe', 'suggestive', 'erotica', 'pornographic'])).optional(),
  "includedTags[]": zod.array(zod.string().uuid()).optional(),
  "includedTagsMode": zod.enum(['AND', 'OR']).optional(),
  "excludedTags[]": zod.array(zod.string().uuid()).optional(),
  "excludedTagsMode": zod.enum(['AND', 'OR']).optional()
})

export const getMangaRandomResponseDataAttributesTitleRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaRandomResponseDataAttributesAltTitlesItemRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaRandomResponseDataAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaRandomResponseDataAttributesAvailableTranslatedLanguagesItemRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const getMangaRandomResponseDataAttributesTagsItemAttributesNameRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaRandomResponseDataAttributesTagsItemAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');


export const getMangaRandomResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['manga']).optional(),
  "attributes": zod.object({
  "title": zod.record(zod.string(), zod.string().regex(getMangaRandomResponseDataAttributesTitleRegExpOne)).optional(),
  "altTitles": zod.array(zod.record(zod.string(), zod.string().regex(getMangaRandomResponseDataAttributesAltTitlesItemRegExpOne))).optional(),
  "description": zod.record(zod.string(), zod.string().regex(getMangaRandomResponseDataAttributesDescriptionRegExpOne)).optional(),
  "isLocked": zod.boolean().optional(),
  "links": zod.record(zod.string(), zod.string()).optional(),
  "originalLanguage": zod.string().optional(),
  "lastVolume": zod.string().nullish(),
  "lastChapter": zod.string().nullish(),
  "publicationDemographic": zod.enum(['shounen', 'shoujo', 'josei', 'seinen']).nullish(),
  "status": zod.enum(['completed', 'ongoing', 'cancelled', 'hiatus']).optional(),
  "year": zod.number().nullish(),
  "contentRating": zod.enum(['safe', 'suggestive', 'erotica', 'pornographic']).optional(),
  "chapterNumbersResetOnNewVolume": zod.boolean().optional(),
  "availableTranslatedLanguages": zod.array(zod.string().regex(getMangaRandomResponseDataAttributesAvailableTranslatedLanguagesItemRegExp)).optional(),
  "latestUploadedChapter": zod.string().uuid().optional(),
  "tags": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['tag']).optional(),
  "attributes": zod.object({
  "name": zod.record(zod.string(), zod.string().regex(getMangaRandomResponseDataAttributesTagsItemAttributesNameRegExpOne)).optional(),
  "description": zod.record(zod.string(), zod.string().regex(getMangaRandomResponseDataAttributesTagsItemAttributesDescriptionRegExpOne)).optional(),
  "group": zod.enum(['content', 'format', 'genre', 'theme']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "state": zod.enum(['draft', 'submitted', 'published', 'rejected']).optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Get MangaDex@Home server URL
 */
export const getAtHomeServerChapterIdQueryParams = zod.object({
  "forcePort443": zod.boolean().optional()
})

export const getAtHomeServerChapterIdResponse = zod.object({
  "result": zod.string().optional(),
  "baseUrl": zod.string().optional(),
  "chapter": zod.object({
  "hash": zod.string().optional(),
  "data": zod.array(zod.string()).optional(),
  "dataSaver": zod.array(zod.string()).optional()
}).optional()
})


/**
 * @summary Tag list
 */
export const getMangaTagResponseDataItemAttributesNameRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaTagResponseDataItemAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');


export const getMangaTagResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['tag']).optional(),
  "attributes": zod.object({
  "name": zod.record(zod.string(), zod.string().regex(getMangaTagResponseDataItemAttributesNameRegExpOne)).optional(),
  "description": zod.record(zod.string(), zod.string().regex(getMangaTagResponseDataItemAttributesDescriptionRegExpOne)).optional(),
  "group": zod.enum(['content', 'format', 'genre', 'theme']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary Logged User details
 */
export const getUserMeResponse = zod.object({
  "result": zod.enum(['ok']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['user']).optional(),
  "attributes": zod.object({
  "username": zod.string().optional(),
  "roles": zod.array(zod.string()).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Get logged User followed Groups
 */
export const getUserFollowsGroupQueryLimitMax = 100;
export const getUserFollowsGroupQueryOffsetMin = 0;


export const getUserFollowsGroupQueryParams = zod.object({
  "limit": zod.number().min(1).max(getUserFollowsGroupQueryLimitMax).optional(),
  "offset": zod.number().min(getUserFollowsGroupQueryOffsetMin).optional(),
  "includes[]": zod.array(zod.enum(['leader', 'member'])).optional()
})

export const getUserFollowsGroupResponseDataItemAttributesAltNamesItemRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getUserFollowsGroupResponseDataItemAttributesTwitterRegExp = new RegExp('^https?:/');
export const getUserFollowsGroupResponseDataItemAttributesMangaUpdatesMax = 128;

export const getUserFollowsGroupResponseDataItemAttributesMangaUpdatesRegExp = new RegExp('^https:\\/\\/www\\.mangaupdates\\.com\\/(group|publisher)(s\\.html\\?id=\\d+|\\/[\\w-]+\\/?([\\w-]+)?(\\/)?)$');
export const getUserFollowsGroupResponseDataItemAttributesFocusedLanguageItemRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const getUserFollowsGroupResponseDataItemAttributesPublishDelayRegExp = new RegExp('^(P([1-9]|[1-9][0-9])D)?(P?([1-9])W)?(P?T(([1-9]|1[0-9]|2[0-4])H)?(([1-9]|[1-5][0-9]|60)M)?(([1-9]|[1-5][0-9]|60)S)?)?$');


export const getUserFollowsGroupResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['scanlation_group']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "altNames": zod.array(zod.record(zod.string(), zod.string().regex(getUserFollowsGroupResponseDataItemAttributesAltNamesItemRegExpOne))).optional(),
  "website": zod.string().nullish(),
  "ircServer": zod.string().nullish(),
  "ircChannel": zod.string().nullish(),
  "discord": zod.string().nullish(),
  "contactEmail": zod.string().nullish(),
  "description": zod.string().nullish(),
  "twitter": zod.string().url().regex(getUserFollowsGroupResponseDataItemAttributesTwitterRegExp).nullish(),
  "mangaUpdates": zod.string().url().max(getUserFollowsGroupResponseDataItemAttributesMangaUpdatesMax).regex(getUserFollowsGroupResponseDataItemAttributesMangaUpdatesRegExp).nullish(),
  "focusedLanguage": zod.array(zod.string().regex(getUserFollowsGroupResponseDataItemAttributesFocusedLanguageItemRegExp)).nullish(),
  "locked": zod.boolean().optional(),
  "official": zod.boolean().optional(),
  "verified": zod.boolean().optional(),
  "inactive": zod.boolean().optional(),
  "exLicensed": zod.boolean().optional(),
  "publishDelay": zod.string().regex(getUserFollowsGroupResponseDataItemAttributesPublishDelayRegExp).optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary Check if logged User follows a Group
 */
export const getUserFollowsGroupIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Get logged User followed User list
 */
export const getUserFollowsUserQueryLimitMax = 100;
export const getUserFollowsUserQueryOffsetMin = 0;


export const getUserFollowsUserQueryParams = zod.object({
  "limit": zod.number().min(1).max(getUserFollowsUserQueryLimitMax).optional(),
  "offset": zod.number().min(getUserFollowsUserQueryOffsetMin).optional()
})

export const getUserFollowsUserResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['user']).optional(),
  "attributes": zod.object({
  "username": zod.string().optional(),
  "roles": zod.array(zod.string()).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary Check if logged User follows a User
 */
export const getUserFollowsUserIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Get logged User followed Manga list
 */
export const getUserFollowsMangaQueryLimitMax = 100;
export const getUserFollowsMangaQueryOffsetMin = 0;


export const getUserFollowsMangaQueryParams = zod.object({
  "limit": zod.number().min(1).max(getUserFollowsMangaQueryLimitMax).optional(),
  "offset": zod.number().min(getUserFollowsMangaQueryOffsetMin).optional(),
  "includes[]": zod.array(zod.enum(['manga', 'cover_art', 'author', 'artist', 'tag', 'creator'])).optional()
})

export const getUserFollowsMangaResponseDataItemAttributesTitleRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getUserFollowsMangaResponseDataItemAttributesAltTitlesItemRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getUserFollowsMangaResponseDataItemAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getUserFollowsMangaResponseDataItemAttributesAvailableTranslatedLanguagesItemRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const getUserFollowsMangaResponseDataItemAttributesTagsItemAttributesNameRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getUserFollowsMangaResponseDataItemAttributesTagsItemAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');


export const getUserFollowsMangaResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['manga']).optional(),
  "attributes": zod.object({
  "title": zod.record(zod.string(), zod.string().regex(getUserFollowsMangaResponseDataItemAttributesTitleRegExpOne)).optional(),
  "altTitles": zod.array(zod.record(zod.string(), zod.string().regex(getUserFollowsMangaResponseDataItemAttributesAltTitlesItemRegExpOne))).optional(),
  "description": zod.record(zod.string(), zod.string().regex(getUserFollowsMangaResponseDataItemAttributesDescriptionRegExpOne)).optional(),
  "isLocked": zod.boolean().optional(),
  "links": zod.record(zod.string(), zod.string()).optional(),
  "originalLanguage": zod.string().optional(),
  "lastVolume": zod.string().nullish(),
  "lastChapter": zod.string().nullish(),
  "publicationDemographic": zod.enum(['shounen', 'shoujo', 'josei', 'seinen']).nullish(),
  "status": zod.enum(['completed', 'ongoing', 'cancelled', 'hiatus']).optional(),
  "year": zod.number().nullish(),
  "contentRating": zod.enum(['safe', 'suggestive', 'erotica', 'pornographic']).optional(),
  "chapterNumbersResetOnNewVolume": zod.boolean().optional(),
  "availableTranslatedLanguages": zod.array(zod.string().regex(getUserFollowsMangaResponseDataItemAttributesAvailableTranslatedLanguagesItemRegExp)).optional(),
  "latestUploadedChapter": zod.string().uuid().optional(),
  "tags": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['tag']).optional(),
  "attributes": zod.object({
  "name": zod.record(zod.string(), zod.string().regex(getUserFollowsMangaResponseDataItemAttributesTagsItemAttributesNameRegExpOne)).optional(),
  "description": zod.record(zod.string(), zod.string().regex(getUserFollowsMangaResponseDataItemAttributesTagsItemAttributesDescriptionRegExpOne)).optional(),
  "group": zod.enum(['content', 'format', 'genre', 'theme']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "state": zod.enum(['draft', 'submitted', 'published', 'rejected']).optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary Check if logged User follows a Manga
 */
export const getUserFollowsMangaIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Get logged User followed CustomList list
 */
export const getUserFollowsListQueryLimitMax = 100;
export const getUserFollowsListQueryOffsetMin = 0;


export const getUserFollowsListQueryParams = zod.object({
  "limit": zod.number().min(1).max(getUserFollowsListQueryLimitMax).optional(),
  "offset": zod.number().min(getUserFollowsListQueryOffsetMin).optional()
})

export const getUserFollowsListResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['custom_list']).optional(),
  "attributes": zod.object({
  "name": zod.string().optional(),
  "visibility": zod.enum(['private', 'public']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary Check if logged User follows a CustomList
 */
export const getUserFollowsListIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Get all Manga reading status for logged User
 */
export const getMangaStatusQueryParams = zod.object({
  "status": zod.enum(['reading', 'on_hold', 'plan_to_read', 'dropped', 're_reading', 'completed']).optional()
})

export const getMangaStatusResponse = zod.object({
  "result": zod.string().optional(),
  "statuses": zod.record(zod.string(), zod.enum(['reading', 'on_hold', 'plan_to_read', 'dropped', 're_reading', 'completed'])).optional()
})


/**
 * @summary Get a Manga reading status
 */
export const getMangaIdStatusResponse = zod.object({
  "result": zod.string().optional(),
  "status": zod.enum(['reading', 'on_hold', 'plan_to_read', 'dropped', 're_reading', 'completed']).optional()
})


/**
 * @summary Update Manga reading status
 */
export const postMangaIdStatusHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const postMangaIdStatusBody = zod.object({
  "status": zod.enum(['reading', 'on_hold', 'plan_to_read', 'dropped', 're_reading', 'completed']).nullable()
})

export const postMangaIdStatusResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Get a specific Manga Draft
 */
export const getMangaIdDraftResponseDataAttributesTitleRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaIdDraftResponseDataAttributesAltTitlesItemRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaIdDraftResponseDataAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaIdDraftResponseDataAttributesAvailableTranslatedLanguagesItemRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const getMangaIdDraftResponseDataAttributesTagsItemAttributesNameRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaIdDraftResponseDataAttributesTagsItemAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');


export const getMangaIdDraftResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['manga']).optional(),
  "attributes": zod.object({
  "title": zod.record(zod.string(), zod.string().regex(getMangaIdDraftResponseDataAttributesTitleRegExpOne)).optional(),
  "altTitles": zod.array(zod.record(zod.string(), zod.string().regex(getMangaIdDraftResponseDataAttributesAltTitlesItemRegExpOne))).optional(),
  "description": zod.record(zod.string(), zod.string().regex(getMangaIdDraftResponseDataAttributesDescriptionRegExpOne)).optional(),
  "isLocked": zod.boolean().optional(),
  "links": zod.record(zod.string(), zod.string()).optional(),
  "originalLanguage": zod.string().optional(),
  "lastVolume": zod.string().nullish(),
  "lastChapter": zod.string().nullish(),
  "publicationDemographic": zod.enum(['shounen', 'shoujo', 'josei', 'seinen']).nullish(),
  "status": zod.enum(['completed', 'ongoing', 'cancelled', 'hiatus']).optional(),
  "year": zod.number().nullish(),
  "contentRating": zod.enum(['safe', 'suggestive', 'erotica', 'pornographic']).optional(),
  "chapterNumbersResetOnNewVolume": zod.boolean().optional(),
  "availableTranslatedLanguages": zod.array(zod.string().regex(getMangaIdDraftResponseDataAttributesAvailableTranslatedLanguagesItemRegExp)).optional(),
  "latestUploadedChapter": zod.string().uuid().optional(),
  "tags": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['tag']).optional(),
  "attributes": zod.object({
  "name": zod.record(zod.string(), zod.string().regex(getMangaIdDraftResponseDataAttributesTagsItemAttributesNameRegExpOne)).optional(),
  "description": zod.record(zod.string(), zod.string().regex(getMangaIdDraftResponseDataAttributesTagsItemAttributesDescriptionRegExpOne)).optional(),
  "group": zod.enum(['content', 'format', 'genre', 'theme']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "state": zod.enum(['draft', 'submitted', 'published', 'rejected']).optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Submit a Manga Draft
 */
export const commitMangaDraftBody = zod.object({
  "version": zod.number().min(1).optional()
})


/**
 * @summary Get a list of Manga Drafts
 */
export const getMangaDraftsResponseDataAttributesTitleRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaDraftsResponseDataAttributesAltTitlesItemRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaDraftsResponseDataAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaDraftsResponseDataAttributesAvailableTranslatedLanguagesItemRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const getMangaDraftsResponseDataAttributesTagsItemAttributesNameRegExpOne = new RegExp('^[a-z]{2,8}$');
export const getMangaDraftsResponseDataAttributesTagsItemAttributesDescriptionRegExpOne = new RegExp('^[a-z]{2,8}$');


export const getMangaDraftsResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['manga']).optional(),
  "attributes": zod.object({
  "title": zod.record(zod.string(), zod.string().regex(getMangaDraftsResponseDataAttributesTitleRegExpOne)).optional(),
  "altTitles": zod.array(zod.record(zod.string(), zod.string().regex(getMangaDraftsResponseDataAttributesAltTitlesItemRegExpOne))).optional(),
  "description": zod.record(zod.string(), zod.string().regex(getMangaDraftsResponseDataAttributesDescriptionRegExpOne)).optional(),
  "isLocked": zod.boolean().optional(),
  "links": zod.record(zod.string(), zod.string()).optional(),
  "originalLanguage": zod.string().optional(),
  "lastVolume": zod.string().nullish(),
  "lastChapter": zod.string().nullish(),
  "publicationDemographic": zod.enum(['shounen', 'shoujo', 'josei', 'seinen']).nullish(),
  "status": zod.enum(['completed', 'ongoing', 'cancelled', 'hiatus']).optional(),
  "year": zod.number().nullish(),
  "contentRating": zod.enum(['safe', 'suggestive', 'erotica', 'pornographic']).optional(),
  "chapterNumbersResetOnNewVolume": zod.boolean().optional(),
  "availableTranslatedLanguages": zod.array(zod.string().regex(getMangaDraftsResponseDataAttributesAvailableTranslatedLanguagesItemRegExp)).optional(),
  "latestUploadedChapter": zod.string().uuid().optional(),
  "tags": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['tag']).optional(),
  "attributes": zod.object({
  "name": zod.record(zod.string(), zod.string().regex(getMangaDraftsResponseDataAttributesTagsItemAttributesNameRegExpOne)).optional(),
  "description": zod.record(zod.string(), zod.string().regex(getMangaDraftsResponseDataAttributesTagsItemAttributesDescriptionRegExpOne)).optional(),
  "group": zod.enum(['content', 'format', 'genre', 'theme']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "state": zod.enum(['draft', 'submitted', 'published', 'rejected']).optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * Captchas can be solved explicitly through this endpoint, another way is to add a `X-Captcha-Result` header to any request. The same logic will verify the captcha and is probably more convenient because it takes one less request.

Authentication is optional. Captchas are tracked for both the client ip and for the user id, if you are logged in you want to send your session token but that is not required.
 * @summary Solve Captcha
 */
export const postCaptchaSolveHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const postCaptchaSolveBody = zod.object({
  "captchaChallenge": zod.string().min(1)
})

export const postCaptchaSolveResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Get a list of report reasons
 */
export const getReportReasonsByCategoryResponseDataItemAttributesReasonRegExpOne = new RegExp('^[a-z]{2,8}$');


export const getReportReasonsByCategoryResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "attributes": zod.object({
  "reason": zod.record(zod.string(), zod.string().regex(getReportReasonsByCategoryResponseDataItemAttributesReasonRegExpOne)).optional(),
  "detailsRequired": zod.boolean().optional(),
  "category": zod.enum(['manga', 'chapter', 'scanlation_group', 'user', 'author']).optional(),
  "version": zod.number().min(1).optional()
}).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary Get a list of reports by the user
 */
export const getReportsQueryLimitMax = 100;
export const getReportsQueryOffsetMin = 0;
export const getReportsQueryReasonIdMin = 36;

export const getReportsQueryReasonIdMax = 36;
export const getReportsQueryObjectIdMin = 36;

export const getReportsQueryObjectIdMax = 36;


export const getReportsQueryParams = zod.object({
  "limit": zod.number().min(1).max(getReportsQueryLimitMax).optional(),
  "offset": zod.number().min(getReportsQueryOffsetMin).optional(),
  "category": zod.enum(['manga', 'chapter', 'scanlation_group', 'user', 'author']).optional(),
  "reasonId": zod.string().uuid().min(getReportsQueryReasonIdMin).max(getReportsQueryReasonIdMax).optional(),
  "objectId": zod.string().uuid().min(getReportsQueryObjectIdMin).max(getReportsQueryObjectIdMax).optional(),
  "status": zod.enum(['waiting', 'accepted', 'refused', 'autoresolved']).optional(),
  "order": zod.object({
  "createdAt": zod.enum(['asc', 'desc']).optional()
}).optional(),
  "includes[]": zod.array(zod.enum(['user', 'reason'])).optional()
})

export const getReportsResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['report']).optional(),
  "attributes": zod.object({
  "details": zod.string().optional(),
  "objectId": zod.string().optional(),
  "status": zod.enum(['waiting', 'accepted', 'refused', 'autoresolved']).optional(),
  "createdAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * @summary Create a new Report
 */
export const postReportHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const postReportBodyReasonMin = 36;

export const postReportBodyReasonMax = 36;
export const postReportBodyObjectIdMin = 36;

export const postReportBodyObjectIdMax = 36;


export const postReportBody = zod.object({
  "category": zod.enum(['manga', 'chapter', 'user', 'scanlation_group', 'author']).optional(),
  "reason": zod.string().uuid().min(postReportBodyReasonMin).max(postReportBodyReasonMax).optional(),
  "objectId": zod.string().uuid().min(postReportBodyObjectIdMin).max(postReportBodyObjectIdMax).optional(),
  "details": zod.string().optional()
})


/**
 * @summary Get the current User upload session
 */
export const getUploadSessionResponse = zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['upload_session']).optional(),
  "attributes": zod.object({
  "isCommitted": zod.boolean().optional(),
  "isProcessed": zod.boolean().optional(),
  "isDeleted": zod.boolean().optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional()
})


/**
 * @summary Start an upload session
 */
export const beginUploadSessionHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const beginUploadSessionBodyGroupsItemMin = 36;

export const beginUploadSessionBodyGroupsItemMax = 36;
export const beginUploadSessionBodyGroupsMax = 10;
export const beginUploadSessionBodyMangaMin = 36;

export const beginUploadSessionBodyMangaMax = 36;


export const beginUploadSessionBody = zod.object({
  "groups": zod.array(zod.string().uuid().min(beginUploadSessionBodyGroupsItemMin).max(beginUploadSessionBodyGroupsItemMax)).max(beginUploadSessionBodyGroupsMax),
  "manga": zod.string().uuid().min(beginUploadSessionBodyMangaMin).max(beginUploadSessionBodyMangaMax)
})

export const beginUploadSessionResponse = zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['upload_session']).optional(),
  "attributes": zod.object({
  "isCommitted": zod.boolean().optional(),
  "isProcessed": zod.boolean().optional(),
  "isDeleted": zod.boolean().optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional()
})


/**
 * @summary Start an edit chapter session
 */
export const beginEditSessionHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const beginEditSessionBody = zod.object({
  "version": zod.number().min(1)
})

export const beginEditSessionResponse = zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['upload_session']).optional(),
  "attributes": zod.object({
  "isCommitted": zod.boolean().optional(),
  "isProcessed": zod.boolean().optional(),
  "isDeleted": zod.boolean().optional(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional()
}).optional()
})


/**
 * @summary Upload images to the upload session
 */
export const putUploadSessionFileHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const putUploadSessionFileResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional(),
  "errors": zod.array(zod.object({
  "id": zod.string().optional(),
  "status": zod.number().optional(),
  "title": zod.string().optional(),
  "detail": zod.string().nullish(),
  "context": zod.string().nullish()
})).optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['upload_session_file']).optional(),
  "attributes": zod.object({
  "originalFileName": zod.string().optional(),
  "fileHash": zod.string().optional(),
  "fileSize": zod.number().optional(),
  "mimeType": zod.string().optional(),
  "source": zod.enum(['local', 'remote']).optional(),
  "version": zod.number().min(1).optional()
}).optional()
})).optional()
})


/**
 * @summary Abandon upload session
 */
export const abandonUploadSessionResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Commit the upload session and specify chapter data
 */
export const commitUploadSessionHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const commitUploadSessionBodyChapterDraftVolumeMax = 8;

export const commitUploadSessionBodyChapterDraftVolumeRegExp = new RegExp('^((0|[1-9]\\d*)(\\.\\d+)?[a-z]?)?$');
export const commitUploadSessionBodyChapterDraftChapterMax = 8;

export const commitUploadSessionBodyChapterDraftChapterRegExp = new RegExp('^((0|[1-9]\\d*)(\\.\\d+)?[a-z]?)?$');
export const commitUploadSessionBodyChapterDraftTitleMax = 255;
export const commitUploadSessionBodyChapterDraftTranslatedLanguageRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const commitUploadSessionBodyChapterDraftExternalUrlMax = 512;

export const commitUploadSessionBodyChapterDraftExternalUrlRegExp = new RegExp('^https?:/');
export const commitUploadSessionBodyChapterDraftPublishAtRegExp = new RegExp('^\\d{4}-[0-1]\\d-([0-2]\\d|3[0-1])T([0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$');
export const commitUploadSessionBodyPageOrderItemMin = 36;

export const commitUploadSessionBodyPageOrderItemMax = 36;
export const commitUploadSessionBodyPageOrderMax = 500;


export const commitUploadSessionBody = zod.object({
  "chapterDraft": zod.object({
  "volume": zod.string().max(commitUploadSessionBodyChapterDraftVolumeMax).regex(commitUploadSessionBodyChapterDraftVolumeRegExp).nullable(),
  "chapter": zod.string().max(commitUploadSessionBodyChapterDraftChapterMax).regex(commitUploadSessionBodyChapterDraftChapterRegExp).nullable(),
  "title": zod.string().max(commitUploadSessionBodyChapterDraftTitleMax).nullable(),
  "translatedLanguage": zod.string().regex(commitUploadSessionBodyChapterDraftTranslatedLanguageRegExp),
  "externalUrl": zod.string().max(commitUploadSessionBodyChapterDraftExternalUrlMax).regex(commitUploadSessionBodyChapterDraftExternalUrlRegExp).nullish(),
  "publishAt": zod.string().regex(commitUploadSessionBodyChapterDraftPublishAtRegExp).optional()
}).optional(),
  "pageOrder": zod.array(zod.string().uuid().min(commitUploadSessionBodyPageOrderItemMin).max(commitUploadSessionBodyPageOrderItemMax)).min(1).max(commitUploadSessionBodyPageOrderMax).optional()
})

export const commitUploadSessionResponseAttributesTitleMax = 255;
export const commitUploadSessionResponseAttributesChapterMax = 8;
export const commitUploadSessionResponseAttributesTranslatedLanguageRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');
export const commitUploadSessionResponseAttributesExternalUrlMax = 512;

export const commitUploadSessionResponseAttributesExternalUrlRegExp = new RegExp('^https?:/');


export const commitUploadSessionResponse = zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['chapter']).optional(),
  "attributes": zod.object({
  "title": zod.string().max(commitUploadSessionResponseAttributesTitleMax).nullish(),
  "volume": zod.string().nullish(),
  "chapter": zod.string().max(commitUploadSessionResponseAttributesChapterMax).nullish(),
  "pages": zod.number().optional(),
  "translatedLanguage": zod.string().regex(commitUploadSessionResponseAttributesTranslatedLanguageRegExp).optional(),
  "uploader": zod.string().uuid().optional(),
  "externalUrl": zod.string().max(commitUploadSessionResponseAttributesExternalUrlMax).regex(commitUploadSessionResponseAttributesExternalUrlRegExp).nullish(),
  "version": zod.number().min(1).optional(),
  "createdAt": zod.string().optional(),
  "updatedAt": zod.string().optional(),
  "publishAt": zod.string().optional(),
  "readableAt": zod.string().optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})


/**
 * @summary Delete an uploaded image from the Upload Session
 */
export const deleteUploadedSessionFileResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Delete a set of uploaded images from the Upload Session
 */
export const deleteUploadedSessionFilesHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const deleteUploadedSessionFilesBodyItem = zod.string().uuid().min(1)
export const deleteUploadedSessionFilesBody = zod.array(deleteUploadedSessionFilesBodyItem)

export const deleteUploadedSessionFilesResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Check if a given manga / locale for a User needs moderation approval
 */
export const uploadCheckApprovalRequiredBodyLocaleRegExp = new RegExp('^[a-z]{2}(-[a-z]{2})?$');


export const uploadCheckApprovalRequiredBody = zod.object({
  "manga": zod.string().uuid().optional(),
  "locale": zod.string().regex(uploadCheckApprovalRequiredBodyLocaleRegExp).optional()
})

export const uploadCheckApprovalRequiredResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
}).and(zod.object({
  "requiresApproval": zod.boolean().optional()
}))


/**
 * @summary Manga relation list
 */
export const getMangaRelationQueryParams = zod.object({
  "includes[]": zod.array(zod.enum(['manga'])).optional()
})

export const getMangaRelationResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['manga_relation']).optional(),
  "attributes": zod.object({
  "relation": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
})).optional(),
  "limit": zod.number().optional(),
  "offset": zod.number().optional(),
  "total": zod.number().optional()
})


/**
 * Create a new Manga relation.
 * @summary Create Manga relation
 */
export const postMangaRelationHeader = zod.object({
  "Content-Type": zod.string().optional()
})

export const postMangaRelationBody = zod.object({
  "targetManga": zod.string().uuid().optional(),
  "relation": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional()
}).and(zod.any())

export const postMangaRelationResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.enum(['manga_relation']).optional(),
  "attributes": zod.object({
  "relation": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "version": zod.number().min(1).optional()
}).optional(),
  "relationships": zod.array(zod.object({
  "id": zod.string().uuid().optional(),
  "type": zod.string().optional(),
  "related": zod.enum(['monochrome', 'main_story', 'adapted_from', 'based_on', 'prequel', 'side_story', 'doujinshi', 'same_franchise', 'shared_universe', 'sequel', 'spin_off', 'alternate_story', 'alternate_version', 'preserialization', 'colored', 'serialization']).optional(),
  "attributes": zod.object({

}).nullish()
})).optional()
}).optional()
})


/**
 * @summary Delete Manga relation
 */
export const deleteMangaRelationIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Get your ratings
 */
export const getRatingQueryParams = zod.object({
  "manga": zod.array(zod.string().uuid())
})

export const getRatingResponse = zod.object({
  "result": zod.string().optional(),
  "ratings": zod.record(zod.string(), zod.object({
  "rating": zod.number().optional(),
  "createdAt": zod.string().datetime().optional()
})).optional()
})


/**
 * @summary Create or update Manga rating
 */
export const postRatingMangaIdBodyRatingMax = 10;


export const postRatingMangaIdBody = zod.object({
  "rating": zod.number().min(1).max(postRatingMangaIdBodyRatingMax).optional()
})

export const postRatingMangaIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Delete Manga rating
 */
export const deleteRatingMangaIdResponse = zod.object({
  "result": zod.enum(['ok', 'error']).optional()
})


/**
 * @summary Get statistics about given chapter
 */
export const getStatisticsChapterUuidParams = zod.object({
  "uuid": zod.string().uuid()
})

export const getStatisticsChapterUuidResponseStatisticsCommentsRepliesCountMin = 0;


export const getStatisticsChapterUuidResponse = zod.object({
  "result": zod.string().optional(),
  "statistics": zod.record(zod.string(), zod.object({
  "comments": zod.object({
  "threadId": zod.number().min(1).optional(),
  "repliesCount": zod.number().min(getStatisticsChapterUuidResponseStatisticsCommentsRepliesCountMin).optional()
}).nullish()
})).optional()
})


/**
 * @summary Get statistics about given chapters
 */
export const getStatisticsChaptersQueryParams = zod.object({
  "chapter[]": zod.array(zod.string().uuid())
})

export const getStatisticsChaptersResponseStatisticsCommentsRepliesCountMin = 0;


export const getStatisticsChaptersResponse = zod.object({
  "result": zod.string().optional(),
  "statistics": zod.record(zod.string(), zod.object({
  "comments": zod.object({
  "threadId": zod.number().min(1).optional(),
  "repliesCount": zod.number().min(getStatisticsChaptersResponseStatisticsCommentsRepliesCountMin).optional()
}).nullish()
})).optional()
})


/**
 * @summary Get statistics about given scanlation group
 */
export const getStatisticsGroupUuidParams = zod.object({
  "uuid": zod.string().uuid()
})

export const getStatisticsGroupUuidResponseStatisticsCommentsRepliesCountMin = 0;


export const getStatisticsGroupUuidResponse = zod.object({
  "result": zod.string().optional(),
  "statistics": zod.record(zod.string(), zod.object({
  "comments": zod.object({
  "threadId": zod.number().min(1).optional(),
  "repliesCount": zod.number().min(getStatisticsGroupUuidResponseStatisticsCommentsRepliesCountMin).optional()
}).nullish()
})).optional()
})


/**
 * @summary Get statistics about given groups
 */
export const getStatisticsGroupsQueryParams = zod.object({
  "group[]": zod.array(zod.string().uuid())
})

export const getStatisticsGroupsResponseStatisticsCommentsRepliesCountMin = 0;


export const getStatisticsGroupsResponse = zod.object({
  "result": zod.string().optional(),
  "statistics": zod.record(zod.string(), zod.object({
  "comments": zod.object({
  "threadId": zod.number().min(1).optional(),
  "repliesCount": zod.number().min(getStatisticsGroupsResponseStatisticsCommentsRepliesCountMin).optional()
}).nullish()
})).optional()
})


/**
 * @summary Get statistics about given Manga
 */
export const getStatisticsMangaUuidParams = zod.object({
  "uuid": zod.string().uuid()
})

export const getStatisticsMangaUuidResponseStatisticsCommentsRepliesCountMin = 0;


export const getStatisticsMangaUuidResponse = zod.object({
  "result": zod.string().optional(),
  "statistics": zod.record(zod.string(), zod.object({
  "comments": zod.object({
  "threadId": zod.number().min(1).optional(),
  "repliesCount": zod.number().min(getStatisticsMangaUuidResponseStatisticsCommentsRepliesCountMin).optional()
}).nullish(),
  "rating": zod.object({
  "average": zod.number().nullish(),
  "bayesian": zod.number().optional(),
  "distribution": zod.object({
  "1": zod.number().optional(),
  "2": zod.number().optional(),
  "3": zod.number().optional(),
  "4": zod.number().optional(),
  "5": zod.number().optional(),
  "6": zod.number().optional(),
  "7": zod.number().optional(),
  "8": zod.number().optional(),
  "9": zod.number().optional(),
  "10": zod.number().optional()
}).optional()
}).optional(),
  "follows": zod.number().optional()
})).optional()
})


/**
 * @summary Find statistics about given Manga
 */
export const getStatisticsMangaQueryParams = zod.object({
  "manga[]": zod.array(zod.string().uuid())
})

export const getStatisticsMangaResponseStatisticsCommentsRepliesCountMin = 0;


export const getStatisticsMangaResponse = zod.object({
  "result": zod.string().optional(),
  "statistics": zod.record(zod.string(), zod.object({
  "comments": zod.object({
  "threadId": zod.number().min(1).optional(),
  "repliesCount": zod.number().min(getStatisticsMangaResponseStatisticsCommentsRepliesCountMin).optional()
}).nullish(),
  "rating": zod.object({
  "average": zod.number().nullish(),
  "bayesian": zod.number().optional()
}).optional(),
  "follows": zod.number().optional()
})).optional()
})


/**
 * @summary Get latest Settings template
 */
export const getSettingsTemplateResponse = zod.object({

})


/**
 * @summary Create Settings template
 */
export const postSettingsTemplateBody = zod.object({

})

export const postSettingsTemplateResponse = zod.object({

})


/**
 * @summary Get Settings template by version id
 */
export const getSettingsTemplateVersionParams = zod.object({
  "version": zod.string().uuid()
})

export const getSettingsTemplateVersionResponse = zod.object({

})


/**
 * @summary Get an User Settings
 */
export const getSettingsResponse = zod.object({
  "result": zod.string().optional(),
  "updatedAt": zod.string().datetime().optional(),
  "settings": zod.object({

}).optional(),
  "template": zod.string().uuid().optional()
})


/**
 * @summary Create or update an User Settings
 */
export const postSettingsBody = zod.object({
  "settings": zod.object({

}).optional(),
  "updatedAt": zod.string().datetime().optional()
})

export const postSettingsResponse = zod.object({
  "result": zod.string().optional(),
  "updatedAt": zod.string().datetime().optional(),
  "settings": zod.object({

}).optional(),
  "template": zod.string().uuid().optional()
})


/**
 * @summary Get users reading history
 */
export const getReadingHistoryResponse = zod.object({
  "result": zod.string().optional(),
  "ratings": zod.array(zod.object({
  "chapterId": zod.string().optional(),
  "readDate": zod.string().datetime().optional()
})).optional()
})


/**
 * Creates a thread in the forums for the given resource, which backs the comments functionality.
A thread is only created if it doesn't exist yet; otherwise the preexisting thread is returned.

 * @summary Create forums thread
 */
export const forumsThreadCreateBody = zod.object({
  "type": zod.enum(['manga', 'group', 'chapter']).optional(),
  "id": zod.string().uuid().optional()
})

export const forumsThreadCreateResponse = zod.object({
  "result": zod.string().optional(),
  "response": zod.string().optional(),
  "data": zod.object({
  "type": zod.string().optional(),
  "id": zod.number().optional(),
  "attributes": zod.object({
  "repliesCount": zod.number().optional()
}).optional()
}).optional()
})


